/***************************************************************************\
* Copyright (c) 2008, Claudio Pica and Agostino Patella                     *
* All rights reserved.                                                      *
\***************************************************************************/

#include <string.h>

// Error checking
#if !defined(_FIELD_TYPE)
#error Missing _FIELD_TYPE in linear_algebra.c
#endif
#if !defined(_FIELD_DIM)
#error Missing _FIELD_DIM in linear_algebra.c
#endif
#if !defined(_SITE_TYPE)
#error Missing _SITE_TYPE in linear_algebra.c
#endif
#if !defined(_REAL)
#error Missing _REAL in linear_algebra.c
#endif
#if !defined(_COMPLEX)
#error Missing _COMPLEX in linear_algebra.c
#endif

// Internal macro for defining generic functions and alias function pointers
#define _CPU_F_NAME_LINA(_name, _suffix) CONCAT(_name##_, _suffix##_cpu)
#define _FUNC_INNER_LINA(_type, _name, _suffix, _args) _type _CPU_F_NAME_LINA(_name, _suffix) _args
#ifdef WITH_GPU
#define _ALIAS_INNER_LINA(_type, _name, _suffix, _args) \
    _type(*_F_NAME(_name##_, _suffix)) _args = _GPU_F_NAME(_name##_, _suffix)
#else
#define _ALIAS_INNER_LINA(_type, _name, _suffix, _args) \
    _type(*_F_NAME(_name##_, _suffix)) _args = _CPU_F_NAME_LINA(_name, _suffix)
#endif

#define _DECLARE_LINEAR_ALGEBRA(_type, _name, _args)     \
    _ALIAS_INNER_LINA(_type, _name, _FIELD_TYPE, _args); \
    _FUNC_INNER_LINA(_type, _name, _FIELD_TYPE, _args)

/* Re <s1,s2> */
_DECLARE_LINEAR_ALGEBRA(double, prod_re, (_FIELD_TYPE * s1, _FIELD_TYPE *s2)) {
    double sum;
    double c; //sum and compensation term

    sum = 0.;
    c = 0.;

    _TWO_SITE_FOR_SUM(s1, s2, sum, c) {
        for (int mu = 0; mu < _FIELD_DIM; ++mu) {
            double prod;
            prod = prod_re(_SITE_PTR(s1, mu, _FIELD_DIM), _SITE_PTR(s2, mu, _FIELD_DIM));
            _2Sum_acc(sum, c, prod);
        }
    }
    sum += c;
#ifdef WITH_MPI
    global_sum(&sum, 1);
#endif
    return sum;
}

/* Im <s1,s2> */
_DECLARE_LINEAR_ALGEBRA(double, prod_im, (_FIELD_TYPE * s1, _FIELD_TYPE *s2)) {
    double sum;
    double c; //sum and compensation term

    sum = 0.;
    c = 0.;

    _TWO_SITE_FOR_SUM(s1, s2, sum, c) {
        for (int mu = 0; mu < _FIELD_DIM; ++mu) {
            double prod;
            prod = prod_im(_SITE_PTR(s1, mu, _FIELD_DIM), _SITE_PTR(s2, mu, _FIELD_DIM));
            _2Sum_acc(sum, c, prod);
        }
    }
    sum += c;
#ifdef WITH_MPI
    global_sum(&sum, 1);
#endif
    return sum;
}

/* <s1,s2> */
_DECLARE_LINEAR_ALGEBRA(hr_complex, prod, (_FIELD_TYPE * s1, _FIELD_TYPE *s2)) {
    hr_complex sum;
    hr_complex c; //compensation term
    _complex_0(sum);
    _complex_0(c);

    _TWO_SITE_FOR_SUM(s1, s2, sum, c) {
        for (int mu = 0; mu < _FIELD_DIM; ++mu) {
            hr_complex prodc; //needed for OMP threads
            prodc = prod(_SITE_PTR(s1, mu, _FIELD_DIM), _SITE_PTR(s2, mu, _FIELD_DIM));
            double s_re = creal(sum);
            double s_im = cimag(sum);
            double c_re = creal(c);
            double c_im = cimag(c);
            _2Sum_acc(s_re, c_re, creal(prodc));
            _2Sum_acc(s_im, c_im, cimag(prodc));
            sum = s_re + s_im * I;
            c = c_re + c_im * I;
        }
    }
    _complex_add_assign(sum, c);
#ifdef WITH_MPI
    global_sum((double *)&sum, 2);
#endif
    return sum;
}

/* Re <s1,s1> */
_DECLARE_LINEAR_ALGEBRA(double, sqnorm, (_FIELD_TYPE * s1)) {
    double sum;
    double c; //compensation term
    sum = 0.;
    c = 0.;

    _ONE_SITE_FOR_SUM(s1, sum, c) {
        for (int mu = 0; mu < _FIELD_DIM; ++mu) {
            double prod;
            prod = prod_re(_SITE_PTR(s1, mu, _FIELD_DIM), _SITE_PTR(s1, mu, _FIELD_DIM));
            _2Sum_acc(sum, c, prod);
        }
    }
    sum += c;
#ifdef WITH_MPI
    global_sum(&sum, 1);
#endif

    return sum;
}

/* Re <s1,s1> */
_DECLARE_LINEAR_ALGEBRA(double, max, (_FIELD_TYPE * s1)) {
    double maxval = 0.;

    _ONE_SITE_FOR_MAX(s1, maxval) {
        for (int mu = 0; mu < _FIELD_DIM; ++mu) {
            double max_loc;
            max_loc = max(_SITE_PTR(s1, mu, _FIELD_DIM));
            maxval = maxval > max_loc ? maxval : max_loc;
        }
    }
#ifdef WITH_MPI
    global_max(&maxval, 1);
#endif

    return maxval;
}