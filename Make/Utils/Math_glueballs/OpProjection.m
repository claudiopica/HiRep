(* ::Package:: *)

BeginPackage["OpProjection`"];
ClearAll["OpProjection`*"];

(*
The general idea is that to add operator you want always to add an entry in these lists:

OpList and 2xOpindex

You must do this coherently otherwise the code will note work.

To identify an operator you use a string for multi tr operators and a path number (PathUniqueIndex) for the 1tr opearators.

The string for the multi-tr operators must be unique for the choice of operators quantum numbers both in input and output:
The standard is "pox poy poz_"irrep out""charge out"_"irrepev" joined by one string for each internal trace "pix piy piz_"irrep i""charge i"

OpList[px,py,pz,irrepidx,charge,<PathUniqueIndex|string>]=Operator implementation (e.g. 2 Pre[az, ax, ay, ay, -ax, -az, -ay, -ay][-1, 0, -1] + 
 2 Pre[az, ax, ay, ay, -ax, -az, -ay, -ay][0, 0, 0] for 1tr op or a list of list which described the 1tr op and their cg coefficients to add 
 eg. {"000_T1minusOhP+_3_011_A1Dic2+_xx-y-xz-xy-z_011_A1Dic2+_xxy-z-x-xz-y", {-(1/4), {0, -1, -1, 1, 1, 1, P[-ax, -ax, az, ax, -ay, ax, -az, ay]}, {0, 1, 1, 1, 1, 1, P[ax, ax, ay, -az, -ax, -ax, az, -ay]}}, ....

Opindex[px,py,pz,irrepidx,charge,<PathUniqueIndex|string>]= multiplet id in Opindex[px,py,pz,irrepidx,charge]

Opindex[px,py,pz,irrepidx,charge]= list of multiplets, each multiplet of the size of the given irrep and the element are either 0 if not evaluated or the opindex. 


pathlist and pathuniqueidentifier

*)






(*
bTOrthog[px,py,pz][[irrep,irerp_ev]]]
bTOrthog is the table of coefficients needed to create the linear combination of paths that transforms according to a definite irrep*)
bTOrthog[-1,-1,-1]={{{1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,-1,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{-I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,0,-I Sqrt[3],0,0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0,0,-2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,-2,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}};
bTOrthog[-1,-1,0]={{{1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}},{{-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}},{{-1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0}},{{1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0}}};
bTOrthog[-1,-1,1]={{{1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{-I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,-I Sqrt[3],0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0,0,0,0,1,-2,0,0,0,0,0,0,0,0,0,0,0,1,-2,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}};
bTOrthog[-1,0,-1]={{{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0}},{{-1,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0}},{{-1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0}},{{1,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0}}};
bTOrthog[-1,0,0]={{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0}},{{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-I Sqrt[2],I Sqrt[2],0,0,0,0,0,0,I Sqrt[2],-I Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,Sqrt[2],-Sqrt[2],0}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,1,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0}}};
bTOrthog[-1,0,1]={{{1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0}},{{-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0}},{{-1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0}},{{1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0}}};
bTOrthog[-1,1,-1]={{{1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,-1,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{-I Sqrt[3],0,0,0,0,0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-I Sqrt[3],0,0,0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,1,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,-2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}};
bTOrthog[-1,1,0]={{{1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}},{{-1,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}},{{-1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0}},{{1,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0}}};
bTOrthog[-1,1,1]={{{1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{-I Sqrt[3],0,0,0,0,0,0,0,0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,0,0,-I Sqrt[3],0,0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,-2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,-2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}};
bTOrthog[0,-1,-1]={{{1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}},{{-1,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}},{{-1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1}},{{1,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1}}};
bTOrthog[0,-1,0]={{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,-1}},{{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,I Sqrt[2],-I Sqrt[2],0,0,0,0,0,0,0,0,0,0,I Sqrt[2],-I Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-Sqrt[2],0,Sqrt[2]}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,-1}}};
bTOrthog[0,-1,1]={{{1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}},{{-1,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}},{{-1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1}},{{1,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1}}};
bTOrthog[0,0,-1]={{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1}},{{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,I Sqrt[2],-I Sqrt[2],0,0,0,0,0,0,0,0,I Sqrt[2],-I Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,Sqrt[2],-Sqrt[2]}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,1,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1}}};
bTOrthog[0,0,0]={{{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}},{{1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,1}},{{1,1,1,1,1,-2,-2,1,-2,-2,1,-2,1,1,-2,1,1,-2,-2,1,1,1,1,1,1,1,1,1,1,-2,-2,1,-2,-2,1,-2,1,1,-2,1,1,-2,-2,1,1,1,1,1},{-Sqrt[3],Sqrt[3],Sqrt[3],-Sqrt[3],-Sqrt[3],0,0,Sqrt[3],0,0,Sqrt[3],0,Sqrt[3],Sqrt[3],0,Sqrt[3],Sqrt[3],0,0,-Sqrt[3],-Sqrt[3],-Sqrt[3],-Sqrt[3],-Sqrt[3],-Sqrt[3],Sqrt[3],Sqrt[3],-Sqrt[3],-Sqrt[3],0,0,Sqrt[3],0,0,Sqrt[3],0,Sqrt[3],Sqrt[3],0,Sqrt[3],Sqrt[3],0,0,-Sqrt[3],-Sqrt[3],-Sqrt[3],-Sqrt[3],-Sqrt[3]}},{{-1+I,-1+I,1-I,1+I,1-I,-1-I,1-I,-1-I,1-I,1+I,1-I,-1+I,-1+I,1+I,-1-I,-1-I,1+I,1+I,-1+I,-1-I,-1+I,1-I,1+I,-1-I,-1+I,-1+I,1-I,1+I,1-I,-1-I,1-I,-1-I,1-I,1+I,1-I,-1+I,-1+I,1+I,-1-I,-1-I,1+I,1+I,-1+I,-1-I,-1+I,1-I,1+I,-1-I},{Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2]},{1+I,1+I,-1-I,-1+I,-1-I,1-I,-1-I,1-I,-1-I,-1+I,-1-I,1+I,1+I,-1+I,1-I,1-I,-1+I,-1+I,1+I,1-I,1+I,-1-I,-1+I,1-I,1+I,1+I,-1-I,-1+I,-1-I,1-I,-1-I,1-I,-1-I,-1+I,-1-I,1+I,1+I,-1+I,1-I,1-I,-1+I,-1+I,1+I,1-I,1+I,-1-I,-1+I,1-I}},{{1+I,-1-I,1+I,1+I,1-I,1+I,-1+I,-1-I,-1+I,-1-I,1-I,1-I,-1+I,1+I,1+I,-1+I,1-I,-1-I,1-I,-1-I,-1+I,-1-I,-1+I,1-I,1+I,-1-I,1+I,1+I,1-I,1+I,-1+I,-1-I,-1+I,-1-I,1-I,1-I,-1+I,1+I,1+I,-1+I,1-I,-1-I,1-I,-1-I,-1+I,-1-I,-1+I,1-I},{Sqrt[2],Sqrt[2],Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],Sqrt[2],Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2]},{1-I,-1+I,1-I,1-I,1+I,1-I,-1-I,-1+I,-1-I,-1+I,1+I,1+I,-1-I,1-I,1-I,-1-I,1+I,-1+I,1+I,-1+I,-1-I,-1+I,-1-I,1+I,1-I,-1+I,1-I,1-I,1+I,1-I,-1-I,-1+I,-1-I,-1+I,1+I,1+I,-1-I,1-I,1-I,-1-I,1+I,-1+I,1+I,-1+I,-1-I,-1+I,-1-I,1+I}},{{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}},{{1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,-1,-1}},{{1,1,1,1,1,-2,-2,1,-2,-2,1,-2,1,1,-2,1,1,-2,-2,1,1,1,1,1,-1,-1,-1,-1,-1,2,2,-1,2,2,-1,2,-1,-1,2,-1,-1,2,2,-1,-1,-1,-1,-1},{-Sqrt[3],Sqrt[3],Sqrt[3],-Sqrt[3],-Sqrt[3],0,0,Sqrt[3],0,0,Sqrt[3],0,Sqrt[3],Sqrt[3],0,Sqrt[3],Sqrt[3],0,0,-Sqrt[3],-Sqrt[3],-Sqrt[3],-Sqrt[3],-Sqrt[3],Sqrt[3],-Sqrt[3],-Sqrt[3],Sqrt[3],Sqrt[3],0,0,-Sqrt[3],0,0,-Sqrt[3],0,-Sqrt[3],-Sqrt[3],0,-Sqrt[3],-Sqrt[3],0,0,Sqrt[3],Sqrt[3],Sqrt[3],Sqrt[3],Sqrt[3]}},{{-1+I,-1+I,1-I,1+I,1-I,-1-I,1-I,-1-I,1-I,1+I,1-I,-1+I,-1+I,1+I,-1-I,-1-I,1+I,1+I,-1+I,-1-I,-1+I,1-I,1+I,-1-I,1-I,1-I,-1+I,-1-I,-1+I,1+I,-1+I,1+I,-1+I,-1-I,-1+I,1-I,1-I,-1-I,1+I,1+I,-1-I,-1-I,1-I,1+I,1-I,-1+I,-1-I,1+I},{Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],Sqrt[2],Sqrt[2]},{1+I,1+I,-1-I,-1+I,-1-I,1-I,-1-I,1-I,-1-I,-1+I,-1-I,1+I,1+I,-1+I,1-I,1-I,-1+I,-1+I,1+I,1-I,1+I,-1-I,-1+I,1-I,-1-I,-1-I,1+I,1-I,1+I,-1+I,1+I,-1+I,1+I,1-I,1+I,-1-I,-1-I,1-I,-1+I,-1+I,1-I,1-I,-1-I,-1+I,-1-I,1+I,1-I,-1+I}},{{Sqrt[2],-Sqrt[2],Sqrt[2],Sqrt[2],-I Sqrt[2],Sqrt[2],I Sqrt[2],-Sqrt[2],I Sqrt[2],-Sqrt[2],-I Sqrt[2],-I Sqrt[2],I Sqrt[2],Sqrt[2],Sqrt[2],I Sqrt[2],-I Sqrt[2],-Sqrt[2],-I Sqrt[2],-Sqrt[2],I Sqrt[2],-Sqrt[2],I Sqrt[2],-I Sqrt[2],-Sqrt[2],Sqrt[2],-Sqrt[2],-Sqrt[2],I Sqrt[2],-Sqrt[2],-I Sqrt[2],Sqrt[2],-I Sqrt[2],Sqrt[2],I Sqrt[2],I Sqrt[2],-I Sqrt[2],-Sqrt[2],-Sqrt[2],-I Sqrt[2],I Sqrt[2],Sqrt[2],I Sqrt[2],Sqrt[2],-I Sqrt[2],Sqrt[2],-I Sqrt[2],I Sqrt[2]},{1-I,1-I,1-I,1-I,-1+I,1-I,-1+I,1-I,-1+I,1-I,-1+I,-1+I,-1+I,1-I,1-I,-1+I,-1+I,1-I,-1+I,1-I,-1+I,1-I,-1+I,-1+I,-1+I,-1+I,-1+I,-1+I,1-I,-1+I,1-I,-1+I,1-I,-1+I,1-I,1-I,1-I,-1+I,-1+I,1-I,1-I,-1+I,1-I,-1+I,1-I,-1+I,1-I,1-I},{-I Sqrt[2],I Sqrt[2],-I Sqrt[2],-I Sqrt[2],Sqrt[2],-I Sqrt[2],-Sqrt[2],I Sqrt[2],-Sqrt[2],I Sqrt[2],Sqrt[2],Sqrt[2],-Sqrt[2],-I Sqrt[2],-I Sqrt[2],-Sqrt[2],Sqrt[2],I Sqrt[2],Sqrt[2],I Sqrt[2],-Sqrt[2],I Sqrt[2],-Sqrt[2],Sqrt[2],I Sqrt[2],-I Sqrt[2],I Sqrt[2],I Sqrt[2],-Sqrt[2],I Sqrt[2],Sqrt[2],-I Sqrt[2],Sqrt[2],-I Sqrt[2],-Sqrt[2],-Sqrt[2],Sqrt[2],I Sqrt[2],I Sqrt[2],Sqrt[2],-Sqrt[2],-I Sqrt[2],-Sqrt[2],-I Sqrt[2],Sqrt[2],-I Sqrt[2],Sqrt[2],-Sqrt[2]}}};
bTOrthog[0,0,1]={{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1}},{{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-I Sqrt[2],I Sqrt[2],0,0,0,0,0,0,0,0,-I Sqrt[2],I Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,Sqrt[2],-Sqrt[2]}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,1,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1}}};
bTOrthog[0,1,-1]={{{1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}},{{-1,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}},{{-1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1}},{{1,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1}}};
bTOrthog[0,1,0]={{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,-1}},{{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-I Sqrt[2],I Sqrt[2],0,0,0,0,0,0,0,0,0,0,-I Sqrt[2],I Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-Sqrt[2],0,Sqrt[2]}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,1,0,0,0,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,-1}}};
bTOrthog[0,1,1]={{{1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}},{{-1,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}},{{-1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1}},{{1,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1}}};
bTOrthog[1,-1,-1]={{{1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{-I Sqrt[3],0,0,0,0,0,0,0,0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,0,0,-I Sqrt[3],0,0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,-2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,-2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}};
bTOrthog[1,-1,0]={{{1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}},{{-1,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}},{{-1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0}},{{1,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0}}};
bTOrthog[1,-1,1]={{{1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,-1,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{-I Sqrt[3],0,0,0,0,0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-I Sqrt[3],0,0,0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,1,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,-2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}};
bTOrthog[1,0,-1]={{{1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0}},{{-1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0}},{{-1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0}},{{1,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0}}};
bTOrthog[1,0,0]={{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0}},{{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,I Sqrt[2],-I Sqrt[2],0,0,0,0,0,0,-I Sqrt[2],I Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-Sqrt[2],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,Sqrt[2],-Sqrt[2],0}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,1,0,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0}}};
bTOrthog[1,0,1]={{{1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0}},{{-1,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0}},{{-1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0}},{{1,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0}}};
bTOrthog[1,1,-1]={{{1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{-I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,-I Sqrt[3],0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0,0,0,0,1,-2,0,0,0,0,0,0,0,0,0,0,0,1,-2,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}};
bTOrthog[1,1,0]={{{1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}},{{-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}},{{-1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0}},{{1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,0}}}; 
bTOrthog[1,1,1]={{{1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,-1,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},{{-I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,0,-I Sqrt[3],0,0,0,I Sqrt[3],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{1,0,0,0,0,0,0,0,0,0,0,-2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,-2,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}};


(*Rotation coefficients for the transformation of a multiplet under a global rotation
e.g. consider the multiplet ml={*,..,*}  ml = irrepSetOrthog[Px,Py,Pz][[irrepindex]][[i]]] . ml' 
where ml' is the multiplet evaluated on a rotated configuration
*)
irrepSetOrthog[0,0,0]={{{{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}},{{{1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{1}}, {{1}}, {{1}}},{{{1, 0}, {0, 1}}, {{1, 0}, {0, -1}}, {{1, 0}, {0, -1}}, {{-1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{-1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{-1/2, Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{-1/2, Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{-1/2, Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{-1/2, -Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{-1/2, -Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{-1/2, Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{-1/2, -Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{-1/2, Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{-1/2, Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{-1/2, -Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{1, 0}, {0, -1}}, {{1, 0}, {0, -1}}, {{-1/2, Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{-1/2, Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{-1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{-1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{1, 0}, {0, 1}}, {{1, 0}, {0, 1}}, {{1, 0}, {0, 1}}, {{1, 0}, {0, 1}}, {{1, 0}, {0, -1}}, {{1, 0}, {0, -1}}, {{-1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{-1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{-1/2, Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{-1/2, Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{-1/2, Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{-1/2, -Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{-1/2, -Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{-1/2, Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{-1/2, -Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{-1/2, Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{-1/2, Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{-1/2, -Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{1, 0}, {0, -1}}, {{1, 0}, {0, -1}}, {{-1/2, Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{-1/2, Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{-1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{-1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{1, 0}, {0, 1}}, {{1, 0}, {0, 1}}, {{1, 0}, {0, 1}}},{{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}, {{0, 0, I}, {0, -1, 0}, {-I, 0, 0}}, {{0, 0, -I}, {0, -1, 0}, {I, 0, 0}}, {{-1/2, I/Sqrt[2], 1/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {1/2, I/Sqrt[2], -1/2}}, {{-1/2, (-I)/Sqrt[2], 1/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {1/2, (-I)/Sqrt[2], -1/2}}, {{-1/2, -(1/Sqrt[2]), -1/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {-1/2, 1/Sqrt[2], -1/2}}, {{-1/2, 1/Sqrt[2], -1/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {-1/2, -(1/Sqrt[2]), -1/2}}, {{-I/2, (-I)/Sqrt[2], -I/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {I/2, (-I)/Sqrt[2], I/2}}, {{I/2, -(1/Sqrt[2]), -I/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {I/2, 1/Sqrt[2], -I/2}}, {{I/2, 1/Sqrt[2], -I/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {I/2, -(1/Sqrt[2]), -I/2}}, {{-I/2, I/Sqrt[2], -I/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {I/2, I/Sqrt[2], I/2}}, {{-I/2, -(1/Sqrt[2]), I/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {-I/2, 1/Sqrt[2], I/2}}, {{I/2, I/Sqrt[2], I/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {-I/2, I/Sqrt[2], -I/2}}, {{I/2, (-I)/Sqrt[2], I/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {-I/2, (-I)/Sqrt[2], -I/2}}, {{-I/2, 1/Sqrt[2], I/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {-I/2, -(1/Sqrt[2]), I/2}}, {{-I, 0, 0}, {0, 1, 0}, {0, 0, I}}, {{I, 0, 0}, {0, 1, 0}, {0, 0, -I}}, {{1/2, -(1/Sqrt[2]), 1/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {1/2, 1/Sqrt[2], 1/2}}, {{1/2, 1/Sqrt[2], 1/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {1/2, -(1/Sqrt[2]), 1/2}}, {{1/2, I/Sqrt[2], -1/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {-1/2, I/Sqrt[2], 1/2}}, {{1/2, (-I)/Sqrt[2], -1/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {-1/2, (-I)/Sqrt[2], 1/2}}, {{-1, 0, 0}, {0, 1, 0}, {0, 0, -1}}, {{0, 0, 1}, {0, -1, 0}, {1, 0, 0}}, {{0, 0, -1}, {0, -1, 0}, {-1, 0, 0}}, {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}, {{0, 0, I}, {0, -1, 0}, {-I, 0, 0}}, {{0, 0, -I}, {0, -1, 0}, {I, 0, 0}}, {{-1/2, I/Sqrt[2], 1/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {1/2, I/Sqrt[2], -1/2}}, {{-1/2, (-I)/Sqrt[2], 1/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {1/2, (-I)/Sqrt[2], -1/2}}, {{-1/2, -(1/Sqrt[2]), -1/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {-1/2, 1/Sqrt[2], -1/2}}, {{-1/2, 1/Sqrt[2], -1/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {-1/2, -(1/Sqrt[2]), -1/2}}, {{-I/2, (-I)/Sqrt[2], -I/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {I/2, (-I)/Sqrt[2], I/2}}, {{I/2, -(1/Sqrt[2]), -I/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {I/2, 1/Sqrt[2], -I/2}}, {{I/2, 1/Sqrt[2], -I/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {I/2, -(1/Sqrt[2]), -I/2}}, {{-I/2, I/Sqrt[2], -I/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {I/2, I/Sqrt[2], I/2}}, {{-I/2, -(1/Sqrt[2]), I/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {-I/2, 1/Sqrt[2], I/2}}, {{I/2, I/Sqrt[2], I/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {-I/2, I/Sqrt[2], -I/2}}, {{I/2, (-I)/Sqrt[2], I/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {-I/2, (-I)/Sqrt[2], -I/2}}, {{-I/2, 1/Sqrt[2], I/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {-I/2, -(1/Sqrt[2]), I/2}}, {{-I, 0, 0}, {0, 1, 0}, {0, 0, I}}, {{I, 0, 0}, {0, 1, 0}, {0, 0, -I}}, {{1/2, -(1/Sqrt[2]), 1/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {1/2, 1/Sqrt[2], 1/2}}, {{1/2, 1/Sqrt[2], 1/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {1/2, -(1/Sqrt[2]), 1/2}}, {{1/2, I/Sqrt[2], -1/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {-1/2, I/Sqrt[2], 1/2}}, {{1/2, (-I)/Sqrt[2], -1/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {-1/2, (-I)/Sqrt[2], 1/2}}, {{-1, 0, 0}, {0, 1, 0}, {0, 0, -1}}, {{0, 0, 1}, {0, -1, 0}, {1, 0, 0}}, {{0, 0, -1}, {0, -1, 0}, {-1, 0, 0}}},{{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}, {{0, 0, -I}, {0, 1, 0}, {I, 0, 0}}, {{0, 0, I}, {0, 1, 0}, {-I, 0, 0}}, {{1/2, I/Sqrt[2], 1/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {1/2, (-I)/Sqrt[2], 1/2}}, {{1/2, (-I)/Sqrt[2], 1/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {1/2, I/Sqrt[2], 1/2}}, {{1/2, 1/Sqrt[2], -1/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {-1/2, 1/Sqrt[2], 1/2}}, {{1/2, -(1/Sqrt[2]), -1/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {-1/2, -(1/Sqrt[2]), 1/2}}, {{I/2, I/Sqrt[2], -I/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {I/2, (-I)/Sqrt[2], -I/2}}, {{-I/2, -(1/Sqrt[2]), -I/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {I/2, -(1/Sqrt[2]), I/2}}, {{-I/2, 1/Sqrt[2], -I/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {I/2, 1/Sqrt[2], I/2}}, {{I/2, (-I)/Sqrt[2], -I/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {I/2, I/Sqrt[2], -I/2}}, {{I/2, -(1/Sqrt[2]), I/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {-I/2, -(1/Sqrt[2]), -I/2}}, {{-I/2, (-I)/Sqrt[2], I/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {-I/2, I/Sqrt[2], I/2}}, {{-I/2, I/Sqrt[2], I/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {-I/2, (-I)/Sqrt[2], I/2}}, {{I/2, 1/Sqrt[2], I/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {-I/2, 1/Sqrt[2], -I/2}}, {{-I, 0, 0}, {0, -1, 0}, {0, 0, I}}, {{I, 0, 0}, {0, -1, 0}, {0, 0, -I}}, {{-1/2, 1/Sqrt[2], 1/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {1/2, 1/Sqrt[2], -1/2}}, {{-1/2, -(1/Sqrt[2]), 1/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {1/2, -(1/Sqrt[2]), -1/2}}, {{-1/2, I/Sqrt[2], -1/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {-1/2, (-I)/Sqrt[2], -1/2}}, {{-1/2, (-I)/Sqrt[2], -1/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {-1/2, I/Sqrt[2], -1/2}}, {{-1, 0, 0}, {0, 1, 0}, {0, 0, -1}}, {{0, 0, -1}, {0, -1, 0}, {-1, 0, 0}}, {{0, 0, 1}, {0, -1, 0}, {1, 0, 0}}, {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}, {{0, 0, -I}, {0, 1, 0}, {I, 0, 0}}, {{0, 0, I}, {0, 1, 0}, {-I, 0, 0}}, {{1/2, I/Sqrt[2], 1/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {1/2, (-I)/Sqrt[2], 1/2}}, {{1/2, (-I)/Sqrt[2], 1/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {1/2, I/Sqrt[2], 1/2}}, {{1/2, 1/Sqrt[2], -1/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {-1/2, 1/Sqrt[2], 1/2}}, {{1/2, -(1/Sqrt[2]), -1/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {-1/2, -(1/Sqrt[2]), 1/2}}, {{I/2, I/Sqrt[2], -I/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {I/2, (-I)/Sqrt[2], -I/2}}, {{-I/2, -(1/Sqrt[2]), -I/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {I/2, -(1/Sqrt[2]), I/2}}, {{-I/2, 1/Sqrt[2], -I/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {I/2, 1/Sqrt[2], I/2}}, {{I/2, (-I)/Sqrt[2], -I/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {I/2, I/Sqrt[2], -I/2}}, {{I/2, -(1/Sqrt[2]), I/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {-I/2, -(1/Sqrt[2]), -I/2}}, {{-I/2, (-I)/Sqrt[2], I/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {-I/2, I/Sqrt[2], I/2}}, {{-I/2, I/Sqrt[2], I/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {-I/2, (-I)/Sqrt[2], I/2}}, {{I/2, 1/Sqrt[2], I/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {-I/2, 1/Sqrt[2], -I/2}}, {{-I, 0, 0}, {0, -1, 0}, {0, 0, I}}, {{I, 0, 0}, {0, -1, 0}, {0, 0, -I}}, {{-1/2, 1/Sqrt[2], 1/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {1/2, 1/Sqrt[2], -1/2}}, {{-1/2, -(1/Sqrt[2]), 1/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {1/2, -(1/Sqrt[2]), -1/2}}, {{-1/2, I/Sqrt[2], -1/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {-1/2, (-I)/Sqrt[2], -1/2}}, {{-1/2, (-I)/Sqrt[2], -1/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {-1/2, I/Sqrt[2], -1/2}}, {{-1, 0, 0}, {0, 1, 0}, {0, 0, -1}}, {{0, 0, -1}, {0, -1, 0}, {-1, 0, 0}}, {{0, 0, 1}, {0, -1, 0}, {1, 0, 0}}},{{{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}},{{{1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{1}}, {{1}}, {{1}}, {{-1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{-1}}, {{-1}}, {{-1}}},{{{1, 0}, {0, 1}}, {{1, 0}, {0, -1}}, {{1, 0}, {0, -1}}, {{-1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{-1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{-1/2, Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{-1/2, Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{-1/2, Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{-1/2, -Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{-1/2, -Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{-1/2, Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{-1/2, -Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{-1/2, Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{-1/2, Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{-1/2, -Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{1, 0}, {0, -1}}, {{1, 0}, {0, -1}}, {{-1/2, Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{-1/2, Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{-1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{-1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{1, 0}, {0, 1}}, {{1, 0}, {0, 1}}, {{1, 0}, {0, 1}}, {{-1, 0}, {0, -1}}, {{-1, 0}, {0, 1}}, {{-1, 0}, {0, 1}}, {{1/2, Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{1/2, Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{1/2, -Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{1/2, Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{1/2, Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{1/2, -Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{1/2, Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{1/2, -Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{1/2, -Sqrt[3]/2}, {Sqrt[3]/2, 1/2}}, {{1/2, Sqrt[3]/2}, {-Sqrt[3]/2, 1/2}}, {{-1, 0}, {0, 1}}, {{-1, 0}, {0, 1}}, {{1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{1/2, -Sqrt[3]/2}, {-Sqrt[3]/2, -1/2}}, {{1/2, Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{1/2, Sqrt[3]/2}, {Sqrt[3]/2, -1/2}}, {{-1, 0}, {0, -1}}, {{-1, 0}, {0, -1}}, {{-1, 0}, {0, -1}}},{{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}, {{0, 0, I}, {0, -1, 0}, {-I, 0, 0}}, {{0, 0, -I}, {0, -1, 0}, {I, 0, 0}}, {{-1/2, I/Sqrt[2], 1/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {1/2, I/Sqrt[2], -1/2}}, {{-1/2, (-I)/Sqrt[2], 1/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {1/2, (-I)/Sqrt[2], -1/2}}, {{-1/2, -(1/Sqrt[2]), -1/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {-1/2, 1/Sqrt[2], -1/2}}, {{-1/2, 1/Sqrt[2], -1/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {-1/2, -(1/Sqrt[2]), -1/2}}, {{-I/2, (-I)/Sqrt[2], -I/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {I/2, (-I)/Sqrt[2], I/2}}, {{I/2, -(1/Sqrt[2]), -I/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {I/2, 1/Sqrt[2], -I/2}}, {{I/2, 1/Sqrt[2], -I/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {I/2, -(1/Sqrt[2]), -I/2}}, {{-I/2, I/Sqrt[2], -I/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {I/2, I/Sqrt[2], I/2}}, {{-I/2, -(1/Sqrt[2]), I/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {-I/2, 1/Sqrt[2], I/2}}, {{I/2, I/Sqrt[2], I/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {-I/2, I/Sqrt[2], -I/2}}, {{I/2, (-I)/Sqrt[2], I/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {-I/2, (-I)/Sqrt[2], -I/2}}, {{-I/2, 1/Sqrt[2], I/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {-I/2, -(1/Sqrt[2]), I/2}}, {{-I, 0, 0}, {0, 1, 0}, {0, 0, I}}, {{I, 0, 0}, {0, 1, 0}, {0, 0, -I}}, {{1/2, -(1/Sqrt[2]), 1/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {1/2, 1/Sqrt[2], 1/2}}, {{1/2, 1/Sqrt[2], 1/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {1/2, -(1/Sqrt[2]), 1/2}}, {{1/2, I/Sqrt[2], -1/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {-1/2, I/Sqrt[2], 1/2}}, {{1/2, (-I)/Sqrt[2], -1/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {-1/2, (-I)/Sqrt[2], 1/2}}, {{-1, 0, 0}, {0, 1, 0}, {0, 0, -1}}, {{0, 0, 1}, {0, -1, 0}, {1, 0, 0}}, {{0, 0, -1}, {0, -1, 0}, {-1, 0, 0}}, {{-1, 0, 0}, {0, -1, 0}, {0, 0, -1}}, {{0, 0, -I}, {0, 1, 0}, {I, 0, 0}}, {{0, 0, I}, {0, 1, 0}, {-I, 0, 0}}, {{1/2, (-I)/Sqrt[2], -1/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {-1/2, (-I)/Sqrt[2], 1/2}}, {{1/2, I/Sqrt[2], -1/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {-1/2, I/Sqrt[2], 1/2}}, {{1/2, 1/Sqrt[2], 1/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {1/2, -(1/Sqrt[2]), 1/2}}, {{1/2, -(1/Sqrt[2]), 1/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {1/2, 1/Sqrt[2], 1/2}}, {{I/2, I/Sqrt[2], I/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {-I/2, I/Sqrt[2], -I/2}}, {{-I/2, 1/Sqrt[2], I/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {-I/2, -(1/Sqrt[2]), I/2}}, {{-I/2, -(1/Sqrt[2]), I/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {-I/2, 1/Sqrt[2], I/2}}, {{I/2, (-I)/Sqrt[2], I/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {-I/2, (-I)/Sqrt[2], -I/2}}, {{I/2, 1/Sqrt[2], -I/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {I/2, -(1/Sqrt[2]), -I/2}}, {{-I/2, (-I)/Sqrt[2], -I/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {I/2, (-I)/Sqrt[2], I/2}}, {{-I/2, I/Sqrt[2], -I/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {I/2, I/Sqrt[2], I/2}}, {{I/2, -(1/Sqrt[2]), -I/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {I/2, 1/Sqrt[2], -I/2}}, {{I, 0, 0}, {0, -1, 0}, {0, 0, -I}}, {{-I, 0, 0}, {0, -1, 0}, {0, 0, I}}, {{-1/2, 1/Sqrt[2], -1/2}, {-(1/Sqrt[2]), 0, 1/Sqrt[2]}, {-1/2, -(1/Sqrt[2]), -1/2}}, {{-1/2, -(1/Sqrt[2]), -1/2}, {1/Sqrt[2], 0, -(1/Sqrt[2])}, {-1/2, 1/Sqrt[2], -1/2}}, {{-1/2, (-I)/Sqrt[2], 1/2}, {(-I)/Sqrt[2], 0, (-I)/Sqrt[2]}, {1/2, (-I)/Sqrt[2], -1/2}}, {{-1/2, I/Sqrt[2], 1/2}, {I/Sqrt[2], 0, I/Sqrt[2]}, {1/2, I/Sqrt[2], -1/2}}, {{1, 0, 0}, {0, -1, 0}, {0, 0, 1}}, {{0, 0, -1}, {0, 1, 0}, {-1, 0, 0}}, {{0, 0, 1}, {0, 1, 0}, {1, 0, 0}}},{{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}, {{0, 0, -I}, {0, 1, 0}, {I, 0, 0}}, {{0, 0, I}, {0, 1, 0}, {-I, 0, 0}}, {{1/2, I/Sqrt[2], 1/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {1/2, (-I)/Sqrt[2], 1/2}}, {{1/2, (-I)/Sqrt[2], 1/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {1/2, I/Sqrt[2], 1/2}}, {{1/2, 1/Sqrt[2], -1/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {-1/2, 1/Sqrt[2], 1/2}}, {{1/2, -(1/Sqrt[2]), -1/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {-1/2, -(1/Sqrt[2]), 1/2}}, {{I/2, I/Sqrt[2], -I/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {I/2, (-I)/Sqrt[2], -I/2}}, {{-I/2, -(1/Sqrt[2]), -I/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {I/2, -(1/Sqrt[2]), I/2}}, {{-I/2, 1/Sqrt[2], -I/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {I/2, 1/Sqrt[2], I/2}}, {{I/2, (-I)/Sqrt[2], -I/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {I/2, I/Sqrt[2], -I/2}}, {{I/2, -(1/Sqrt[2]), I/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {-I/2, -(1/Sqrt[2]), -I/2}}, {{-I/2, (-I)/Sqrt[2], I/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {-I/2, I/Sqrt[2], I/2}}, {{-I/2, I/Sqrt[2], I/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {-I/2, (-I)/Sqrt[2], I/2}}, {{I/2, 1/Sqrt[2], I/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {-I/2, 1/Sqrt[2], -I/2}}, {{-I, 0, 0}, {0, -1, 0}, {0, 0, I}}, {{I, 0, 0}, {0, -1, 0}, {0, 0, -I}}, {{-1/2, 1/Sqrt[2], 1/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {1/2, 1/Sqrt[2], -1/2}}, {{-1/2, -(1/Sqrt[2]), 1/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {1/2, -(1/Sqrt[2]), -1/2}}, {{-1/2, I/Sqrt[2], -1/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {-1/2, (-I)/Sqrt[2], -1/2}}, {{-1/2, (-I)/Sqrt[2], -1/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {-1/2, I/Sqrt[2], -1/2}}, {{-1, 0, 0}, {0, 1, 0}, {0, 0, -1}}, {{0, 0, -1}, {0, -1, 0}, {-1, 0, 0}}, {{0, 0, 1}, {0, -1, 0}, {1, 0, 0}}, {{-1, 0, 0}, {0, -1, 0}, {0, 0, -1}}, {{0, 0, I}, {0, -1, 0}, {-I, 0, 0}}, {{0, 0, -I}, {0, -1, 0}, {I, 0, 0}}, {{-1/2, (-I)/Sqrt[2], -1/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {-1/2, I/Sqrt[2], -1/2}}, {{-1/2, I/Sqrt[2], -1/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {-1/2, (-I)/Sqrt[2], -1/2}}, {{-1/2, -(1/Sqrt[2]), 1/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {1/2, -(1/Sqrt[2]), -1/2}}, {{-1/2, 1/Sqrt[2], 1/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {1/2, 1/Sqrt[2], -1/2}}, {{-I/2, (-I)/Sqrt[2], I/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {-I/2, I/Sqrt[2], I/2}}, {{I/2, 1/Sqrt[2], I/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {-I/2, 1/Sqrt[2], -I/2}}, {{I/2, -(1/Sqrt[2]), I/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {-I/2, -(1/Sqrt[2]), -I/2}}, {{-I/2, I/Sqrt[2], I/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {-I/2, (-I)/Sqrt[2], I/2}}, {{-I/2, 1/Sqrt[2], -I/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {I/2, 1/Sqrt[2], I/2}}, {{I/2, I/Sqrt[2], -I/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {I/2, (-I)/Sqrt[2], -I/2}}, {{I/2, (-I)/Sqrt[2], -I/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {I/2, I/Sqrt[2], -I/2}}, {{-I/2, -(1/Sqrt[2]), -I/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {I/2, -(1/Sqrt[2]), I/2}}, {{I, 0, 0}, {0, 1, 0}, {0, 0, -I}}, {{-I, 0, 0}, {0, 1, 0}, {0, 0, I}}, {{1/2, -(1/Sqrt[2]), -1/2}, {1/Sqrt[2], 0, 1/Sqrt[2]}, {-1/2, -(1/Sqrt[2]), 1/2}}, {{1/2, 1/Sqrt[2], -1/2}, {-(1/Sqrt[2]), 0, -(1/Sqrt[2])}, {-1/2, 1/Sqrt[2], 1/2}}, {{1/2, (-I)/Sqrt[2], 1/2}, {(-I)/Sqrt[2], 0, I/Sqrt[2]}, {1/2, I/Sqrt[2], 1/2}}, {{1/2, I/Sqrt[2], 1/2}, {I/Sqrt[2], 0, (-I)/Sqrt[2]}, {1/2, (-I)/Sqrt[2], 1/2}}, {{1, 0, 0}, {0, -1, 0}, {0, 0, 1}}, {{0, 0, 1}, {0, 1, 0}, {1, 0, 0}}, {{0, 0, -1}, {0, 1, 0}, {-1, 0, 0}}}};
irrepSetOrthog[0,0,1]={{{{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}},{{{1}}, {{1}}, {{1}}, {{1}}, {{-1}}, {{-1}}, {{-1}}, {{-1}}},{{{1, 0}, {0, 1}}, {{0, I}, {I, 0}}, {{0, -I}, {-I, 0}}, {{-1, 0}, {0, -1}}, {{0, -I}, {I, 0}}, {{0, I}, {-I, 0}}, {{-1, 0}, {0, 1}}, {{1, 0}, {0, -1}}},{{{1}}, {{-1}}, {{-1}}, {{1}}, {{-1}}, {{-1}}, {{1}}, {{1}}},{{{1}}, {{-1}}, {{-1}}, {{1}}, {{1}}, {{1}}, {{-1}}, {{-1}}}};
irrepSetOrthog[0,1,1]={{{{1}}, {{1}}, {{1}}, {{1}}},{{{1}}, {{1}}, {{-1}}, {{-1}}},{{{1}}, {{-1}}, {{-1}}, {{1}}},{{{1}}, {{-1}}, {{1}}, {{-1}}}};
irrepSetOrthog[1,1,1]={{{{1}}, {{1}}, {{1}}, {{1}}, {{1}}, {{1}}},{{{1}}, {{1}}, {{1}}, {{-1}}, {{-1}}, {{-1}}},{{{1, 0}, {0, 1}}, {{-1/2, (I/2)*Sqrt[3]}, {(I/2)*Sqrt[3], -1/2}}, {{-1/2, (-I/2)*Sqrt[3]}, {(-I/2)*Sqrt[3], -1/2}}, {{1/2, (-I/2)*Sqrt[3]}, {(I/2)*Sqrt[3], -1/2}}, {{1/2, (I/2)*Sqrt[3]}, {(-I/2)*Sqrt[3], -1/2}}, {{-1, 0}, {0, 1}}}};
irrepSetOrthog[px_,py_,pz_] := Module[{Pxsort,Pysort,Pzsort},
  {Pxsort,Pysort,Pzsort}=Sort[{px,py,pz}//Abs];
  irrepSetOrthog[px,py,pz]=irrepSetOrthog[Pxsort,Pysort,Pzsort];
  irrepSetOrthog[px,py,pz]
  ];


(*Number of rotations in the little group of the chosen momentum *)
Ord[px_,py_,pz_] := Module[{},
  Ord[px,py,pz]=Length[permTab[px,py,pz]];
  Ord[px,py,pz]];


(*
rotations (written as permutation) in the little group of the chosen momentum.
Note two tables are added for convenience:
permutationTable == permTab[0,0,0]
and 
inversepermutationTable == permutationTable^-1
*)
permutationTable = {{ax -> bx, ay -> by, az -> bz},{ax -> by, ay -> bx, az -> -bz},{ax -> -by, ay -> -bx, az -> -bz},{ax -> -bx, ay -> bz, az -> by},{ax -> -bx, ay -> -bz, az -> -by},{ax -> bz, ay -> -by, az -> bx},{ax -> -bz, ay -> -by, az -> -bx},{ax -> -by, ay -> -bz, az -> bx},{ax -> bz, ay -> -bx, az -> -by},{ax -> -bz, ay -> -bx, az -> by},{ax -> -by, ay -> bz, az -> -bx},{ax -> bz, ay -> bx, az -> by},{ax -> by, ay -> bz, az -> bx},{ax -> by, ay -> -bz, az -> -bx},{ax -> -bz, ay -> bx, az -> -by},{ax -> -by, ay -> bx, az -> bz},{ax -> by, ay -> -bx, az -> bz},{ax -> bz, ay -> by, az -> -bx},{ax -> -bz, ay -> by, az -> bx},{ax -> bx, ay -> bz, az -> -by},{ax -> bx, ay -> -bz, az -> by},{ax -> -bx, ay -> -by, az -> bz},{ax -> -bx, ay -> by, az -> -bz},{ax -> bx, ay -> -by, az -> -bz},{ax -> -bx, ay -> -by, az -> -bz},{ax -> -by, ay -> -bx, az -> bz},{ax -> by, ay -> bx, az -> bz},{ax -> bx, ay -> -bz, az -> -by},{ax -> bx, ay -> bz, az -> by},{ax -> -bz, ay -> by, az -> -bx},{ax -> bz, ay -> by, az -> bx},{ax -> by, ay -> bz, az -> -bx},{ax -> -bz, ay -> bx, az -> by},{ax -> bz, ay -> bx, az -> -by},{ax -> by, ay -> -bz, az -> bx},{ax -> -bz, ay -> -bx, az -> -by},{ax -> -by, ay -> -bz, az -> -bx},{ax -> -by, ay -> bz, az -> bx},{ax -> bz, ay -> -bx, az -> by},{ax -> by, ay -> -bx, az -> -bz},{ax -> -by, ay -> bx, az -> -bz},{ax -> -bz, ay -> -by, az -> bx},{ax -> bz, ay -> -by, az -> -bx},{ax -> -bx, ay -> -bz, az -> by},{ax -> -bx, ay -> bz, az -> -by},{ax -> bx, ay -> by, az -> -bz},{ax -> bx, ay -> -by, az -> bz},{ax -> -bx, ay -> by, az -> bz}};
inversepermutationTable = {{ax -> bx, ay -> by, az -> bz},{ay -> bx, ax -> by, az -> -bz},{ay -> -bx, ax -> -by, az -> -bz},{ax -> -bx, az -> by, ay -> bz},{ax -> -bx, az -> -by, ay -> -bz},{az -> bx, ay -> -by, ax -> bz},{az -> -bx, ay -> -by, ax -> -bz},{ay -> -bx, az -> -by, ax -> bz},{az -> bx, ax -> -by, ay -> -bz},{az -> -bx, ax -> -by, ay -> bz},{ay -> -bx, az -> by, ax -> -bz},{az -> bx, ax -> by, ay -> bz},{ay -> bx, az -> by, ax -> bz},{ay -> bx, az -> -by, ax -> -bz},{az -> -bx, ax -> by, ay -> -bz},{ay -> -bx, ax -> by, az -> bz},{ay -> bx, ax -> -by, az -> bz},{az -> bx, ay -> by, ax -> -bz},{az -> -bx, ay -> by, ax -> bz},{ax -> bx, az -> by, ay -> -bz},{ax -> bx, az -> -by, ay -> bz},{ax -> -bx, ay -> -by, az -> bz},{ax -> -bx, ay -> by, az -> -bz},{ax -> bx, ay -> -by, az -> -bz},{ax -> -bx, ay -> -by, az -> -bz},{ay -> -bx, ax -> -by, az -> bz},{ay -> bx, ax -> by, az -> bz},{ax -> bx, az -> -by, ay -> -bz},{ax -> bx, az -> by, ay -> bz},{az -> -bx, ay -> by, ax -> -bz},{az -> bx, ay -> by, ax -> bz},{ay -> bx, az -> by, ax -> -bz},{az -> -bx, ax -> by, ay -> bz},{az -> bx, ax -> by, ay -> -bz},{ay -> bx, az -> -by, ax -> bz},{az -> -bx, ax -> -by, ay -> -bz},{ay -> -bx, az -> -by, ax -> -bz},{ay -> -bx, az -> by, ax -> bz},{az -> bx, ax -> -by, ay -> bz},{ay -> bx, ax -> -by, az -> -bz},{ay -> -bx, ax -> by, az -> -bz},{az -> -bx, ay -> -by, ax -> bz},{az -> bx, ay -> -by, ax -> -bz},{ax -> -bx, az -> -by, ay -> bz},{ax -> -bx, az -> by, ay -> -bz},{ax -> bx, ay -> by, az -> -bz},{ax -> bx, ay -> -by, az -> bz},{ax -> -bx, ay -> by, az -> bz}};

permTab[-1,-1,-1]={{ax->bx,ay->by,az->bz},{ax->bz,ay->bx,az->by},{ax->by,ay->bz,az->bx},{ax->by,ay->bx,az->bz},{ax->bx,ay->bz,az->by},{ax->bz,ay->by,az->bx}}
permTab[-1,-1,0]={{ax->bx,ay->by,az->bz},{ax->by,ay->bx,az->-bz},{ax->by,ay->bx,az->bz},{ax->bx,ay->by,az->-bz}}
permTab[-1,-1,1]={{ax->bx,ay->by,az->bz},{ax->-bz,ay->bx,az->-by},{ax->by,ay->-bz,az->-bx},{ax->by,ay->bx,az->bz},{ax->bx,ay->-bz,az->-by},{ax->-bz,ay->by,az->-bx}}
permTab[-1,0,-1]={{ax->bx,ay->by,az->bz},{ax->bz,ay->-by,az->bx},{ax->bz,ay->by,az->bx},{ax->bx,ay->-by,az->bz}}
permTab[-1,0,0]={{ax->bx,ay->by,az->bz},{ax->bx,ay->bz,az->-by},{ax->bx,ay->-bz,az->by},{ax->bx,ay->-by,az->-bz},{ax->bx,ay->bz,az->by},{ax->bx,ay->-bz,az->-by},{ax->bx,ay->by,az->-bz},{ax->bx,ay->-by,az->bz}}
permTab[-1,0,1]={{ax->bx,ay->by,az->bz},{ax->-bz,ay->-by,az->-bx},{ax->-bz,ay->by,az->-bx},{ax->bx,ay->-by,az->bz}}
permTab[-1,1,-1]={{ax->bx,ay->by,az->bz},{ax->bz,ay->-bx,az->-by},{ax->-by,ay->-bz,az->bx},{ax->-by,ay->-bx,az->bz},{ax->bx,ay->-bz,az->-by},{ax->bz,ay->by,az->bx}}
permTab[-1,1,0]={{ax->bx,ay->by,az->bz},{ax->-by,ay->-bx,az->-bz},{ax->-by,ay->-bx,az->bz},{ax->bx,ay->by,az->-bz}}
permTab[-1,1,1]={{ax->bx,ay->by,az->bz},{ax->-bz,ay->-bx,az->by},{ax->-by,ay->bz,az->-bx},{ax->-by,ay->-bx,az->bz},{ax->bx,ay->bz,az->by},{ax->-bz,ay->by,az->-bx}}
permTab[0,-1,-1]={{ax->bx,ay->by,az->bz},{ax->-bx,ay->bz,az->by},{ax->bx,ay->bz,az->by},{ax->-bx,ay->by,az->bz}}
permTab[0,-1,0]={{ax->bx,ay->by,az->bz},{ax->-bz,ay->by,az->bx},{ax->bz,ay->by,az->-bx},{ax->-bx,ay->by,az->-bz},{ax->bz,ay->by,az->bx},{ax->-bz,ay->by,az->-bx},{ax->-bx,ay->by,az->bz},{ax->bx,ay->by,az->-bz}}
permTab[0,-1,1]={{ax->bx,ay->by,az->bz},{ax->-bx,ay->-bz,az->-by},{ax->bx,ay->-bz,az->-by},{ax->-bx,ay->by,az->bz}}
permTab[0,0,-1]={{ax->bx,ay->by,az->bz},{ax->by,ay->-bx,az->bz},{ax->-by,ay->bx,az->bz},{ax->-bx,ay->-by,az->bz},{ax->by,ay->bx,az->bz},{ax->-by,ay->-bx,az->bz},{ax->bx,ay->-by,az->bz},{ax->-bx,ay->by,az->bz}}
permTab[0,0,0]={{ax->bx,ay->by,az->bz},{ax->by,ay->bx,az->-bz},{ax->-by,ay->-bx,az->-bz},{ax->-bx,ay->bz,az->by},{ax->-bx,ay->-bz,az->-by},{ax->bz,ay->-by,az->bx},{ax->-bz,ay->-by,az->-bx},{ax->-by,ay->-bz,az->bx},{ax->bz,ay->-bx,az->-by},{ax->-bz,ay->-bx,az->by},{ax->-by,ay->bz,az->-bx},{ax->bz,ay->bx,az->by},{ax->by,ay->bz,az->bx},{ax->by,ay->-bz,az->-bx},{ax->-bz,ay->bx,az->-by},{ax->-by,ay->bx,az->bz},{ax->by,ay->-bx,az->bz},{ax->bz,ay->by,az->-bx},{ax->-bz,ay->by,az->bx},{ax->bx,ay->bz,az->-by},{ax->bx,ay->-bz,az->by},{ax->-bx,ay->-by,az->bz},{ax->-bx,ay->by,az->-bz},{ax->bx,ay->-by,az->-bz},{ax->-bx,ay->-by,az->-bz},{ax->-by,ay->-bx,az->bz},{ax->by,ay->bx,az->bz},{ax->bx,ay->-bz,az->-by},{ax->bx,ay->bz,az->by},{ax->-bz,ay->by,az->-bx},{ax->bz,ay->by,az->bx},{ax->by,ay->bz,az->-bx},{ax->-bz,ay->bx,az->by},{ax->bz,ay->bx,az->-by},{ax->by,ay->-bz,az->bx},{ax->-bz,ay->-bx,az->-by},{ax->-by,ay->-bz,az->-bx},{ax->-by,ay->bz,az->bx},{ax->bz,ay->-bx,az->by},{ax->by,ay->-bx,az->-bz},{ax->-by,ay->bx,az->-bz},{ax->-bz,ay->-by,az->bx},{ax->bz,ay->-by,az->-bx},{ax->-bx,ay->-bz,az->by},{ax->-bx,ay->bz,az->-by},{ax->bx,ay->by,az->-bz},{ax->bx,ay->-by,az->bz},{ax->-bx,ay->by,az->bz}}
permTab[0,0,1]={{ax->bx,ay->by,az->bz},{ax->-by,ay->bx,az->bz},{ax->by,ay->-bx,az->bz},{ax->-bx,ay->-by,az->bz},{ax->-by,ay->-bx,az->bz},{ax->by,ay->bx,az->bz},{ax->bx,ay->-by,az->bz},{ax->-bx,ay->by,az->bz}}
permTab[0,1,-1]={{ax->bx,ay->by,az->bz},{ax->-bx,ay->-bz,az->-by},{ax->bx,ay->-bz,az->-by},{ax->-bx,ay->by,az->bz}}
permTab[0,1,0]={{ax->bx,ay->by,az->bz},{ax->bz,ay->by,az->-bx},{ax->-bz,ay->by,az->bx},{ax->-bx,ay->by,az->-bz},{ax->-bz,ay->by,az->-bx},{ax->bz,ay->by,az->bx},{ax->-bx,ay->by,az->bz},{ax->bx,ay->by,az->-bz}}
permTab[0,1,1]={{ax->bx,ay->by,az->bz},{ax->-bx,ay->bz,az->by},{ax->bx,ay->bz,az->by},{ax->-bx,ay->by,az->bz}}
permTab[1,-1,-1]={{ax->bx,ay->by,az->bz},{ax->-bz,ay->-bx,az->by},{ax->-by,ay->bz,az->-bx},{ax->-by,ay->-bx,az->bz},{ax->bx,ay->bz,az->by},{ax->-bz,ay->by,az->-bx}}
permTab[1,-1,0]={{ax->bx,ay->by,az->bz},{ax->-by,ay->-bx,az->-bz},{ax->-by,ay->-bx,az->bz},{ax->bx,ay->by,az->-bz}}
permTab[1,-1,1]={{ax->bx,ay->by,az->bz},{ax->bz,ay->-bx,az->-by},{ax->-by,ay->-bz,az->bx},{ax->-by,ay->-bx,az->bz},{ax->bx,ay->-bz,az->-by},{ax->bz,ay->by,az->bx}}
permTab[1,0,-1]={{ax->bx,ay->by,az->bz},{ax->-bz,ay->-by,az->-bx},{ax->-bz,ay->by,az->-bx},{ax->bx,ay->-by,az->bz}}
permTab[1,0,0]={{ax->bx,ay->by,az->bz},{ax->bx,ay->-bz,az->by},{ax->bx,ay->bz,az->-by},{ax->bx,ay->-by,az->-bz},{ax->bx,ay->-bz,az->-by},{ax->bx,ay->bz,az->by},{ax->bx,ay->by,az->-bz},{ax->bx,ay->-by,az->bz}}
permTab[1,0,1]={{ax->bx,ay->by,az->bz},{ax->bz,ay->-by,az->bx},{ax->bz,ay->by,az->bx},{ax->bx,ay->-by,az->bz}}
permTab[1,1,-1]={{ax->bx,ay->by,az->bz},{ax->-bz,ay->bx,az->-by},{ax->by,ay->-bz,az->-bx},{ax->by,ay->bx,az->bz},{ax->bx,ay->-bz,az->-by},{ax->-bz,ay->by,az->-bx}}
permTab[1,1,0]={{ax->bx,ay->by,az->bz},{ax->by,ay->bx,az->-bz},{ax->by,ay->bx,az->bz},{ax->bx,ay->by,az->-bz}}
permTab[1,1,1]={{ax->bx,ay->by,az->bz},{ax->bz,ay->bx,az->by},{ax->by,ay->bz,az->bx},{ax->by,ay->bx,az->bz},{ax->bx,ay->bz,az->by},{ax->bz,ay->by,az->bx}}

btoa = {bx -> ax, by -> ay, bz -> az};


(*Finds one of the permutation-rotation that sends p1 in p2*)
findPerm[p1_, p2_] := findPerm[p1, p2] = Module[{res, i = 0, lperm = Length[permutationTable]},
   While[i < lperm,
      i++;
      res = ({ax, ay, az} //. inversepermutationTable[[i]]) //. {bx -> p1[[1]], by -> p1[[2]], bz -> p1[[3]]};
      If[p2 == res, lperm = i];
    ];
   permutationTable[[i]]];

(*Naming conventions for the irreps of the given momentum*)
IrrepName[0,0,0] = {A1plusOhP, A2plusOhP, EplusOhP, T1plusOhP, T2plusOhP, 
    A1minusOhP, A2minusOhP, EminusOhP, T1minusOhP, T2minusOhP};
IrrepName[0,0,1] = {A1Dic4, A2Dic4, E2Dic4, B1Dic4, B2Dic4};
IrrepName[0,1,1] = {A1Dic2, A2Dic2, B1Dic2, B2Dic2};
IrrepName[1,1,1] = {A1Dic3, A2Dic3, EEDic3};
IrrepName[px_,py_,pz_] := Module[{Pxsort,Pysort,Pzsort},
  {Pxsort,Pysort,Pzsort}=Sort[{px,py,pz}//Abs];
  IrrepName[px,py,pz]=IrrepName[Pxsort,Pysort,Pzsort];
  IrrepName[px,py,pz]];


dir[ax]=1;
dir[-ax]=1;
dir[ay]=2;
dir[-ay]=2;
dir[az]=3;
dir[-az]=3;
posdir[ax]=True;
posdir[ay]=True;
posdir[az]=True;
posdir[-ax]=False;
posdir[-ay]=False;
posdir[-az]=False;
p[-2]=m2;
p[-1]=m1;
p[0]=0;
p[1]=1;
p[2]=2;
stcharge[+1]="+";
stcharge[-1]="-";


(*names setup and location of the created files*)
makefilestrm = OpenRead["./Makefile"];
While[True,
 makefileline = StringDelete[ReadLine[makefilestrm], " "];
 topdir = StringCases[makefileline, "TOPDIR=" ~~ x__ -> x];
 If[topdir != {} 0, Break[]]
 ]
Close[makefilestrm];

opfilename = topdir<>"/LibHR/Observables/glueballs_op.c";
headerfilename = topdir<>"/Include/glueballs.h";
checkfunctionsfilename= topdir<>"/TestProgram/Utils/check_utils_3_functions.c";

MyRangeString[min_, max_] := Module[{string = ""},
   Do[string = string <> " " <> ToString[i], {i, min, max}];
   string];


(*This function defines the unique string for 2tr operators  pratically defined by: 
pxout, pyout, pzout, irrepidxout, irrepevout, charge, path1, px1, py1, pz1, irrepidx1, charge1, path2, px2, py2, pz2, irrepidx2, charge2*)
Set2trstring[pxout_, pyout_, pzout_, irrepidxout_, irrepevout_, charge_, path1_, px1_, py1_, pz1_, irrepidx1_, charge1_, path2_, px2_, py2_, pz2_, irrepidx2_, charge2_] := 
  Module[{psx1, psy1, psz1, psx2, psy2, psz2, psxout, psyout, pszout, irnameout, irname1, irname2, stringout, string1, string2, s1, s2, string},
   {psx1, psy1, psz1} = Sort[{px1, py1, pz1} // Abs];
   {psx2, psy2, psz2} = Sort[{px2, py2, pz2} // Abs];
   {psxout, psyout, pszout} = Sort[{pxout, pyout, pzout} // Abs];
   irnameout = IrrepName[psxout, psyout, pszout][[irrepidxout]];
   irname1 = IrrepName[px1, py1, pz1][[irrepidx1]];
   irname2 = IrrepName[px2, py2, pz2][[irrepidx2]];
   stringout = ToString[pxout] <> ToString[pyout] <> ToString[pzout] <> "_" <> ToString[irnameout]<> stcharge[charge] <> "_" <>ToString[irrepevout] <> "_" ;
   string1 = ToString[psx1] <> ToString[psy1] <> ToString[psz1] <> "_" <> ToString[irname1] <> stcharge[charge1] <> "_";
   string2 = ToString[psx2] <> ToString[psy2] <> ToString[psz2] <> "_" <> ToString[irname2] <> stcharge[charge2] <> "_";
   s1 = PathUniqueIdentifier[path1][[1]] //. {P[A__][b__] :> {A}, Conjugate[P[B__][c__]] :> {B}};
   s2 = PathUniqueIdentifier[path2][[1]] //. {P[A__][b__] :> {A}, Conjugate[P[B__][c__]] :> {B}};
   Do[step = s1[[i]] //. {ax -> x, ay -> y, az -> z};
      string1 = string1 <> ToString[step];
    , {i, 1, Length[s1]}];
   Do[step = s2[[i]] //. {ax -> x, ay -> y, az -> z};
      string2 = string2 <> ToString[step];
    , {i, 1, Length[s2]}];
   If[OrderedQ[{string1, string2}], 
      string = string1 <> "_" <> string2;, 
      string = string2 <> "_" <> string1;
    ];
  stringout <> string];

(*this function inserts into Opindex the unique string identifying the operator*)
Set2trOpidx[string_, pxout_, pyout_, pzout_, irrepidxout_, irrepevout_, charge_] := Module[{pos, tmp, lstring,stringelem},
  If[Not[ListQ[Opindex[pxout, pyout, pzout, irrepidxout, charge]]],
    tmp = {Table[0, {i, 1, Length[bTOrthog[pxout, pyout, pzout][[irrepidxout]]]}]};
    tmp[[1, irrepevout]] = string;
    Opindex[pxout, pyout, pzout, irrepidxout, charge] = tmp;
  ];
  tmp = Opindex[pxout, pyout, pzout, irrepidxout, charge];
  (*lstring contains only part of the string because the multiplet is created by the same set of operators but with different ev.
  To this end we take only the part of the string that doesn't contain the ev.*)
  
  lstring = StringSplit[string, "_", 4][[-1]];

  (*We select all the elements that match the pattern, at most one multiplet can match*)  
  stringelem = Position[tmp, _?(StringQ[#] &)]; (*all the strings in opindex for the given channel*)
  pos = {};
  Do[
   If[StringMatchQ[tmp[[el[[1]], el[[2]]]], "*" <> lstring],
     AppendTo[pos, el[[1]]];
    ];
  ,{el, stringelem}];
  pos = Union[pos];
  If[Length[pos] > 1, Print["Multiple 2tr operators are trying to be inserted with the same identification string"]; Abort[];];
  If[pos == {},
    tmp = Table[0, {i, 1,Length[bTOrthog[pxout, pyout, pzout][[irrepidxout]]]}];
    tmp[[irrepevout]] = string;
    AppendTo[Opindex[pxout, pyout, pzout, irrepidxout, charge], tmp];
   ,
    tmp = Opindex[pxout, pyout, pzout, irrepidxout, charge];
    tmp[[pos[[1]], irrepevout]] = string;
    Opindex[pxout, pyout, pzout, irrepidxout, charge] = tmp;
  ];
]

(*This is the interface function that defines the insertion of two trace operators into Opindex and OpList (here is it to be understood that we insert operators that are already momenutm defined)*)
Add2trOpCorrelators[path1_,px1_, py1_, pz1_, irrepidx1_,charge1_, path2_,px2_, py2_, pz2_, irrepidx2_, charge2_,pxout_, pyout_, pzout_, irrepidxout_, irrepevout_]:= Module[{aa,res,success=0,CG,irname1,irname2,irnameout,cg,lridx1,lridx2,lchg1,lchg2,lpath1,lpath2,lres,cg1,i,cc,lpx1,lpy1,lpz1,lpx2,lpy2,lpz2,lev1,lev2,charge=charge1*charge2,tmp,res1,res2,oo,psx1, psy1, psz1, psx2, psy2, psz2},
  If[Not[ListQ[bTOrthog[px1, py1, pz1]]] || Not[ListQ[bTOrthog[px2, py2, pz2]]] || Not[ListQ[bTOrthog[pxout, pyout, pzout]]],    Print["Missing Coefficient table for the given impulse"];Abort[];];
  If[Length[bTOrthog[px1, py1, pz1]] < irrepidx1 || irrepidx1 < 1 , Print["Number of irreps is not compatible with the requested irrep index"];Abort[];];
  If[Length[bTOrthog[px2, py2, pz2]] < irrepidx2 || irrepidx2 < 1 , Print["Number of irreps is not compatible with the requested irrep index"];Abort[];];
  If[Length[bTOrthog[pxout, pyout, pzout]] < irrepidxout || irrepidxout < 1 , Print["Number of irreps is not compatible with the requested irrep index"];Abort[];];
  If[Length[bTOrthog[pxout, pyout, pzout][[irrepidxout]]] < irrepevout || irrepevout < 1,  Print["Irrep dimension is not compatible with the requested irrep ev"];Abort[];];
  If[Not[Or[charge1==-1, charge1==+1]],Print["Charge can only take values +1 or -1"];Abort[];];
  If[Not[Or[charge2==-1, charge2==+1]],Print["Charge can only take values +1 or -1"];Abort[];];
  {psx1, psy1, psz1}=Sort[{px1, py1, pz1} // Abs];
  {psx2, psy2, psz2}=Sort[{px2, py2, pz2} // Abs];
  CG[{0,0,1},A1Dic4,{0,0,1},A1Dic4,{0,0,0},A1plusOhP,1]={{1/Sqrt[6],{{0,0,1},1},{{0,0,-1},1}},{1/Sqrt[6],{{0,0,-1},1},{{0,0,1},1}},{1/Sqrt[6],{{0,1,0},1},{{0,-1,0},1}},{1/Sqrt[6],{{0,-1,0},1},{{0,1,0},1}},{1/Sqrt[6],{{1,0,0},1},{{-1,0,0},1}},{1/Sqrt[6],{{-1,0,0},1},{{1,0,0},1}}};
  CG[{0,0,1},A1Dic4,{0,0,1},A1Dic4,{0,0,0},EplusOhP,1]={{1/Sqrt[3],{{0,0,1},1},{{0,0,-1},1}},{1/Sqrt[3],{{0,0,-1},1},{{0,0,1},1}},{-(1/(2 Sqrt[3])),{{0,1,0},1},{{0,-1,0},1}},{-(1/(2 Sqrt[3])),{{0,-1,0},1},{{0,1,0},1}},{-(1/(2 Sqrt[3])),{{1,0,0},1},{{-1,0,0},1}},{-(1/(2 Sqrt[3])),{{-1,0,0},1},{{1,0,0},1}}};
  CG[{0,0,1},A1Dic4,{0,0,1},A1Dic4,{0,0,0},EplusOhP,2]={{0,{{0,0,1},1},{{0,0,-1},1}},{0,{{0,0,-1},1},{{0,0,1},1}},{-(1/2),{{0,1,0},1},{{0,-1,0},1}},{-(1/2),{{0,-1,0},1},{{0,1,0},1}},{1/2,{{1,0,0},1},{{-1,0,0},1}},{1/2,{{-1,0,0},1},{{1,0,0},1}}};
  CG[{0,0,1},A1Dic4,{0,0,1},A1Dic4,{0,0,0},T1minusOhP,1]={{0,{{0,0,1},1},{{0,0,-1},1}},{0,{{0,0,-1},1},{{0,0,1},1}},{-(I/2),{{0,1,0},1},{{0,-1,0},1}},{I/2,{{0,-1,0},1},{{0,1,0},1}},{-(1/2),{{1,0,0},1},{{-1,0,0},1}},{1/2,{{-1,0,0},1},{{1,0,0},1}}};
  CG[{0,0,1},A1Dic4,{0,0,1},A1Dic4,{0,0,0},T1minusOhP,2]={{1/Sqrt[2],{{0,0,1},1},{{0,0,-1},1}},{-(1/Sqrt[2]),{{0,0,-1},1},{{0,0,1},1}},{0,{{0,1,0},1},{{0,-1,0},1}},{0,{{0,-1,0},1},{{0,1,0},1}},{0,{{1,0,0},1},{{-1,0,0},1}},{0,{{-1,0,0},1},{{1,0,0},1}}};
  CG[{0,0,1},A1Dic4,{0,0,1},A1Dic4,{0,0,0},T1minusOhP,3]={{0,{{0,0,1},1},{{0,0,-1},1}},{0,{{0,0,-1},1},{{0,0,1},1}},{-(I/2),{{0,1,0},1},{{0,-1,0},1}},{I/2,{{0,-1,0},1},{{0,1,0},1}},{1/2,{{1,0,0},1},{{-1,0,0},1}},{-(1/2),{{-1,0,0},1},{{1,0,0},1}}};
  CG[{0,1,1},A1Dic2,{0,1,1},A1Dic2,{0,0,0},A1plusOhP,1]={{1/(2 Sqrt[3]),{{0,1,1},1},{{0,-1,-1},1}},{1/(2 Sqrt[3]),{{1,0,-1},1},{{-1,0,1},1}},{1/(2 Sqrt[3]),{{-1,0,-1},1},{{1,0,1},1}},{1/(2 Sqrt[3]),{{0,-1,-1},1},{{0,1,1},1}},{1/(2 Sqrt[3]),{{1,-1,0},1},{{-1,1,0},1}},{1/(2 Sqrt[3]),{{-1,-1,0},1},{{1,1,0},1}},{1/(2 Sqrt[3]),{{-1,0,1},1},{{1,0,-1},1}},{1/(2 Sqrt[3]),{{-1,1,0},1},{{1,-1,0},1}},{1/(2 Sqrt[3]),{{1,0,1},1},{{-1,0,-1},1}},{1/(2 Sqrt[3]),{{1,1,0},1},{{-1,-1,0},1}},{1/(2 Sqrt[3]),{{0,1,-1},1},{{0,-1,1},1}},{1/(2 Sqrt[3]),{{0,-1,1},1},{{0,1,-1},1}}};
  CG[{0,1,1},A1Dic2,{0,1,1},A1Dic2,{0,0,0},EplusOhP,1]={{1/(2 Sqrt[6]),{{0,1,1},1},{{0,-1,-1},1}},{1/(2 Sqrt[6]),{{1,0,-1},1},{{-1,0,1},1}},{1/(2 Sqrt[6]),{{-1,0,-1},1},{{1,0,1},1}},{1/(2 Sqrt[6]),{{0,-1,-1},1},{{0,1,1},1}},{-(1/Sqrt[6]),{{1,-1,0},1},{{-1,1,0},1}},{-(1/Sqrt[6]),{{-1,-1,0},1},{{1,1,0},1}},{1/(2 Sqrt[6]),{{-1,0,1},1},{{1,0,-1},1}},{-(1/Sqrt[6]),{{-1,1,0},1},{{1,-1,0},1}},{1/(2 Sqrt[6]),{{1,0,1},1},{{-1,0,-1},1}},{-(1/Sqrt[6]),{{1,1,0},1},{{-1,-1,0},1}},{1/(2 Sqrt[6]),{{0,1,-1},1},{{0,-1,1},1}},{1/(2 Sqrt[6]),{{0,-1,1},1},{{0,1,-1},1}}};
  CG[{0,1,1},A1Dic2,{0,1,1},A1Dic2,{0,0,0},EplusOhP,2]={{-(1/(2 Sqrt[2])),{{0,1,1},1},{{0,-1,-1},1}},{1/(2 Sqrt[2]),{{1,0,-1},1},{{-1,0,1},1}},{1/(2 Sqrt[2]),{{-1,0,-1},1},{{1,0,1},1}},{-(1/(2 Sqrt[2])),{{0,-1,-1},1},{{0,1,1},1}},{0,{{1,-1,0},1},{{-1,1,0},1}},{0,{{-1,-1,0},1},{{1,1,0},1}},{1/(2 Sqrt[2]),{{-1,0,1},1},{{1,0,-1},1}},{0,{{-1,1,0},1},{{1,-1,0},1}},{1/(2 Sqrt[2]),{{1,0,1},1},{{-1,0,-1},1}},{0,{{1,1,0},1},{{-1,-1,0},1}},{-(1/(2 Sqrt[2])),{{0,1,-1},1},{{0,-1,1},1}},{-(1/(2 Sqrt[2])),{{0,-1,1},1},{{0,1,-1},1}}};
  CG[{0,1,1},A1Dic2,{0,1,1},A1Dic2,{0,0,0},T1minusOhP,1]={{1/4,{{0,1,1},1},{{0,-1,-1},1}},{-(I/4),{{1,0,-1},1},{{-1,0,1},1}},{I/4,{{-1,0,-1},1},{{1,0,1},1}},{-(1/4),{{0,-1,-1},1},{{0,1,1},1}},{-(1/4)-I/4,{{1,-1,0},1},{{-1,1,0},1}},{-(1/4)+I/4,{{-1,-1,0},1},{{1,1,0},1}},{I/4,{{-1,0,1},1},{{1,0,-1},1}},{1/4+I/4,{{-1,1,0},1},{{1,-1,0},1}},{-(I/4),{{1,0,1},1},{{-1,0,-1},1}},{1/4-I/4,{{1,1,0},1},{{-1,-1,0},1}},{1/4,{{0,1,-1},1},{{0,-1,1},1}},{-(1/4),{{0,-1,1},1},{{0,1,-1},1}}};
  CG[{0,1,1},A1Dic2,{0,1,1},A1Dic2,{0,0,0},T1minusOhP,2]={{I/(2 Sqrt[2]),{{0,1,1},1},{{0,-1,-1},1}},{-(I/(2 Sqrt[2])),{{1,0,-1},1},{{-1,0,1},1}},{-(I/(2 Sqrt[2])),{{-1,0,-1},1},{{1,0,1},1}},{-(I/(2 Sqrt[2])),{{0,-1,-1},1},{{0,1,1},1}},{0,{{1,-1,0},1},{{-1,1,0},1}},{0,{{-1,-1,0},1},{{1,1,0},1}},{I/(2 Sqrt[2]),{{-1,0,1},1},{{1,0,-1},1}},{0,{{-1,1,0},1},{{1,-1,0},1}},{I/(2 Sqrt[2]),{{1,0,1},1},{{-1,0,-1},1}},{0,{{1,1,0},1},{{-1,-1,0},1}},{-(I/(2 Sqrt[2])),{{0,1,-1},1},{{0,-1,1},1}},{I/(2 Sqrt[2]),{{0,-1,1},1},{{0,1,-1},1}}};
  CG[{0,1,1},A1Dic2,{0,1,1},A1Dic2,{0,0,0},T1minusOhP,3]={{1/4,{{0,1,1},1},{{0,-1,-1},1}},{I/4,{{1,0,-1},1},{{-1,0,1},1}},{-(I/4),{{-1,0,-1},1},{{1,0,1},1}},{-(1/4),{{0,-1,-1},1},{{0,1,1},1}},{-(1/4)+I/4,{{1,-1,0},1},{{-1,1,0},1}},{-(1/4)-I/4,{{-1,-1,0},1},{{1,1,0},1}},{-(I/4),{{-1,0,1},1},{{1,0,-1},1}},{1/4-I/4,{{-1,1,0},1},{{1,-1,0},1}},{I/4,{{1,0,1},1},{{-1,0,-1},1}},{1/4+I/4,{{1,1,0},1},{{-1,-1,0},1}},{1/4,{{0,1,-1},1},{{0,-1,1},1}},{-(1/4),{{0,-1,1},1},{{0,1,-1},1}}};
  CG[{0,1,1},A1Dic2,{0,1,1},A1Dic2,{0,0,0},T2minusOhP,1]={{1/4,{{0,1,1},1},{{0,-1,-1},1}},{-(I/4),{{1,0,-1},1},{{-1,0,1},1}},{I/4,{{-1,0,-1},1},{{1,0,1},1}},{-(1/4),{{0,-1,-1},1},{{0,1,1},1}},{1/4+I/4,{{1,-1,0},1},{{-1,1,0},1}},{1/4-I/4,{{-1,-1,0},1},{{1,1,0},1}},{I/4,{{-1,0,1},1},{{1,0,-1},1}},{-(1/4)-I/4,{{-1,1,0},1},{{1,-1,0},1}},{-(I/4),{{1,0,1},1},{{-1,0,-1},1}},{-(1/4)+I/4,{{1,1,0},1},{{-1,-1,0},1}},{1/4,{{0,1,-1},1},{{0,-1,1},1}},{-(1/4),{{0,-1,1},1},{{0,1,-1},1}}};
  CG[{0,1,1},A1Dic2,{0,1,1},A1Dic2,{0,0,0},T2minusOhP,2]={{I/(2 Sqrt[2]),{{0,1,1},1},{{0,-1,-1},1}},{I/(2 Sqrt[2]),{{1,0,-1},1},{{-1,0,1},1}},{I/(2 Sqrt[2]),{{-1,0,-1},1},{{1,0,1},1}},{-(I/(2 Sqrt[2])),{{0,-1,-1},1},{{0,1,1},1}},{0,{{1,-1,0},1},{{-1,1,0},1}},{0,{{-1,-1,0},1},{{1,1,0},1}},{-(I/(2 Sqrt[2])),{{-1,0,1},1},{{1,0,-1},1}},{0,{{-1,1,0},1},{{1,-1,0},1}},{-(I/(2 Sqrt[2])),{{1,0,1},1},{{-1,0,-1},1}},{0,{{1,1,0},1},{{-1,-1,0},1}},{-(I/(2 Sqrt[2])),{{0,1,-1},1},{{0,-1,1},1}},{I/(2 Sqrt[2]),{{0,-1,1},1},{{0,1,-1},1}}};
  CG[{0,1,1},A1Dic2,{0,1,1},A1Dic2,{0,0,0},T2minusOhP,3]={{-(1/4),{{0,1,1},1},{{0,-1,-1},1}},{-(I/4),{{1,0,-1},1},{{-1,0,1},1}},{I/4,{{-1,0,-1},1},{{1,0,1},1}},{1/4,{{0,-1,-1},1},{{0,1,1},1}},{-(1/4)+I/4,{{1,-1,0},1},{{-1,1,0},1}},{-(1/4)-I/4,{{-1,-1,0},1},{{1,1,0},1}},{I/4,{{-1,0,1},1},{{1,0,-1},1}},{1/4-I/4,{{-1,1,0},1},{{1,-1,0},1}},{-(I/4),{{1,0,1},1},{{-1,0,-1},1}},{1/4+I/4,{{1,1,0},1},{{-1,-1,0},1}},{-(1/4),{{0,1,-1},1},{{0,-1,1},1}},{1/4,{{0,-1,1},1},{{0,1,-1},1}}};
  CG[{0,1,1},A1Dic2,{0,1,1},A1Dic2,{0,0,0},T2plusOhP,1]={{1/(2 Sqrt[2]),{{0,1,1},1},{{0,-1,-1},1}},{I/(2 Sqrt[2]),{{1,0,-1},1},{{-1,0,1},1}},{-(I/(2 Sqrt[2])),{{-1,0,-1},1},{{1,0,1},1}},{1/(2 Sqrt[2]),{{0,-1,-1},1},{{0,1,1},1}},{0,{{1,-1,0},1},{{-1,1,0},1}},{0,{{-1,-1,0},1},{{1,1,0},1}},{I/(2 Sqrt[2]),{{-1,0,1},1},{{1,0,-1},1}},{0,{{-1,1,0},1},{{1,-1,0},1}},{-(I/(2 Sqrt[2])),{{1,0,1},1},{{-1,0,-1},1}},{0,{{1,1,0},1},{{-1,-1,0},1}},{-(1/(2 Sqrt[2])),{{0,1,-1},1},{{0,-1,1},1}},{-(1/(2 Sqrt[2])),{{0,-1,1},1},{{0,1,-1},1}}};
  CG[{0,1,1},A1Dic2,{0,1,1},A1Dic2,{0,0,0},T2plusOhP,2]={{0,{{0,1,1},1},{{0,-1,-1},1}},{0,{{1,0,-1},1},{{-1,0,1},1}},{0,{{-1,0,-1},1},{{1,0,1},1}},{0,{{0,-1,-1},1},{{0,1,1},1}},{1/2,{{1,-1,0},1},{{-1,1,0},1}},{-(1/2),{{-1,-1,0},1},{{1,1,0},1}},{0,{{-1,0,1},1},{{1,0,-1},1}},{1/2,{{-1,1,0},1},{{1,-1,0},1}},{0,{{1,0,1},1},{{-1,0,-1},1}},{-(1/2),{{1,1,0},1},{{-1,-1,0},1}},{0,{{0,1,-1},1},{{0,-1,1},1}},{0,{{0,-1,1},1},{{0,1,-1},1}}};
  CG[{0,1,1},A1Dic2,{0,1,1},A1Dic2,{0,0,0},T2plusOhP,3]={{1/(2 Sqrt[2]),{{0,1,1},1},{{0,-1,-1},1}},{-(I/(2 Sqrt[2])),{{1,0,-1},1},{{-1,0,1},1}},{I/(2 Sqrt[2]),{{-1,0,-1},1},{{1,0,1},1}},{1/(2 Sqrt[2]),{{0,-1,-1},1},{{0,1,1},1}},{0,{{1,-1,0},1},{{-1,1,0},1}},{0,{{-1,-1,0},1},{{1,1,0},1}},{-(I/(2 Sqrt[2])),{{-1,0,1},1},{{1,0,-1},1}},{0,{{-1,1,0},1},{{1,-1,0},1}},{I/(2 Sqrt[2]),{{1,0,1},1},{{-1,0,-1},1}},{0,{{1,1,0},1},{{-1,-1,0},1}},{-(1/(2 Sqrt[2])),{{0,1,-1},1},{{0,-1,1},1}},{-(1/(2 Sqrt[2])),{{0,-1,1},1},{{0,1,-1},1}}};
  CG[{1,1,1},A1Dic3,{1,1,1},A1Dic3,{0,0,0},A1plusOhP,1]={{1/(2 Sqrt[2]),{{1,1,1},1},{{-1,-1,-1},1}},{1/(2 Sqrt[2]),{{1,1,-1},1},{{-1,-1,1},1}},{1/(2 Sqrt[2]),{{-1,-1,-1},1},{{1,1,1},1}},{1/(2 Sqrt[2]),{{-1,1,1},1},{{1,-1,-1},1}},{1/(2 Sqrt[2]),{{1,-1,1},1},{{-1,1,-1},1}},{1/(2 Sqrt[2]),{{-1,-1,1},1},{{1,1,-1},1}},{1/(2 Sqrt[2]),{{1,-1,-1},1},{{-1,1,1},1}},{1/(2 Sqrt[2]),{{-1,1,-1},1},{{1,-1,1},1}}};
  CG[{1,1,1},A1Dic3,{1,1,1},A1Dic3,{0,0,0},A2minusOhP,1]={{1/(2 Sqrt[2]),{{1,1,1},1},{{-1,-1,-1},1}},{-(1/(2 Sqrt[2])),{{1,1,-1},1},{{-1,-1,1},1}},{-(1/(2 Sqrt[2])),{{-1,-1,-1},1},{{1,1,1},1}},{-(1/(2 Sqrt[2])),{{-1,1,1},1},{{1,-1,-1},1}},{-(1/(2 Sqrt[2])),{{1,-1,1},1},{{-1,1,-1},1}},{1/(2 Sqrt[2]),{{-1,-1,1},1},{{1,1,-1},1}},{1/(2 Sqrt[2]),{{1,-1,-1},1},{{-1,1,1},1}},{1/(2 Sqrt[2]),{{-1,1,-1},1},{{1,-1,1},1}}};
  CG[{1,1,1},A1Dic3,{1,1,1},A1Dic3,{0,0,0},T1minusOhP,1]={{1/(2 Sqrt[2]),{{1,1,1},1},{{-1,-1,-1},1}},{1/(2 Sqrt[2]),{{1,1,-1},1},{{-1,-1,1},1}},{-(1/(2 Sqrt[2])),{{-1,-1,-1},1},{{1,1,1},1}},{I/(2 Sqrt[2]),{{-1,1,1},1},{{1,-1,-1},1}},{-(I/(2 Sqrt[2])),{{1,-1,1},1},{{-1,1,-1},1}},{-(1/(2 Sqrt[2])),{{-1,-1,1},1},{{1,1,-1},1}},{-(I/(2 Sqrt[2])),{{1,-1,-1},1},{{-1,1,1},1}},{I/(2 Sqrt[2]),{{-1,1,-1},1},{{1,-1,1},1}}};
  CG[{1,1,1},A1Dic3,{1,1,1},A1Dic3,{0,0,0},T1minusOhP,2]={{(-1)^(3/4)/(2 Sqrt[2]),{{1,1,1},1},{{-1,-1,-1},1}},{-((-1)^(3/4)/(2 Sqrt[2])),{{1,1,-1},1},{{-1,-1,1},1}},{-((-1)^(3/4)/(2 Sqrt[2])),{{-1,-1,-1},1},{{1,1,1},1}},{(-1)^(3/4)/(2 Sqrt[2]),{{-1,1,1},1},{{1,-1,-1},1}},{(-1)^(3/4)/(2 Sqrt[2]),{{1,-1,1},1},{{-1,1,-1},1}},{(-1)^(3/4)/(2 Sqrt[2]),{{-1,-1,1},1},{{1,1,-1},1}},{-((-1)^(3/4)/(2 Sqrt[2])),{{1,-1,-1},1},{{-1,1,1},1}},{-((-1)^(3/4)/(2 Sqrt[2])),{{-1,1,-1},1},{{1,-1,1},1}}};
  CG[{1,1,1},A1Dic3,{1,1,1},A1Dic3,{0,0,0},T1minusOhP,3]={{I/(2 Sqrt[2]),{{1,1,1},1},{{-1,-1,-1},1}},{I/(2 Sqrt[2]),{{1,1,-1},1},{{-1,-1,1},1}},{-(I/(2 Sqrt[2])),{{-1,-1,-1},1},{{1,1,1},1}},{1/(2 Sqrt[2]),{{-1,1,1},1},{{1,-1,-1},1}},{-(1/(2 Sqrt[2])),{{1,-1,1},1},{{-1,1,-1},1}},{-(I/(2 Sqrt[2])),{{-1,-1,1},1},{{1,1,-1},1}},{-(1/(2 Sqrt[2])),{{1,-1,-1},1},{{-1,1,1},1}},{1/(2 Sqrt[2]),{{-1,1,-1},1},{{1,-1,1},1}}};
  CG[{1,1,1},A1Dic3,{1,1,1},A1Dic3,{0,0,0},T2plusOhP,1]={{-(I/(2 Sqrt[2])),{{1,1,1},1},{{-1,-1,-1},1}},{I/(2 Sqrt[2]),{{1,1,-1},1},{{-1,-1,1},1}},{-(I/(2 Sqrt[2])),{{-1,-1,-1},1},{{1,1,1},1}},{1/(2 Sqrt[2]),{{-1,1,1},1},{{1,-1,-1},1}},{-(1/(2 Sqrt[2])),{{1,-1,1},1},{{-1,1,-1},1}},{I/(2 Sqrt[2]),{{-1,-1,1},1},{{1,1,-1},1}},{1/(2 Sqrt[2]),{{1,-1,-1},1},{{-1,1,1},1}},{-(1/(2 Sqrt[2])),{{-1,1,-1},1},{{1,-1,1},1}}};
  CG[{1,1,1},A1Dic3,{1,1,1},A1Dic3,{0,0,0},T2plusOhP,2]={{(-1)^(3/4)/(2 Sqrt[2]),{{1,1,1},1},{{-1,-1,-1},1}},{(-1)^(3/4)/(2 Sqrt[2]),{{1,1,-1},1},{{-1,-1,1},1}},{(-1)^(3/4)/(2 Sqrt[2]),{{-1,-1,-1},1},{{1,1,1},1}},{-((-1)^(3/4)/(2 Sqrt[2])),{{-1,1,1},1},{{1,-1,-1},1}},{-((-1)^(3/4)/(2 Sqrt[2])),{{1,-1,1},1},{{-1,1,-1},1}},{(-1)^(3/4)/(2 Sqrt[2]),{{-1,-1,1},1},{{1,1,-1},1}},{-((-1)^(3/4)/(2 Sqrt[2])),{{1,-1,-1},1},{{-1,1,1},1}},{-((-1)^(3/4)/(2 Sqrt[2])),{{-1,1,-1},1},{{1,-1,1},1}}};
  CG[{1,1,1},A1Dic3,{1,1,1},A1Dic3,{0,0,0},T2plusOhP,3]={{1/(2 Sqrt[2]),{{1,1,1},1},{{-1,-1,-1},1}},{-(1/(2 Sqrt[2])),{{1,1,-1},1},{{-1,-1,1},1}},{1/(2 Sqrt[2]),{{-1,-1,-1},1},{{1,1,1},1}},{-(I/(2 Sqrt[2])),{{-1,1,1},1},{{1,-1,-1},1}},{I/(2 Sqrt[2]),{{1,-1,1},1},{{-1,1,-1},1}},{-(1/(2 Sqrt[2])),{{-1,-1,1},1},{{1,1,-1},1}},{-(I/(2 Sqrt[2])),{{1,-1,-1},1},{{-1,1,1},1}},{I/(2 Sqrt[2]),{{-1,1,-1},1},{{1,-1,1},1}}};

  irname1=IrrepName[px1, py1, pz1][[irrepidx1]];
  irname2=IrrepName[px2, py2, pz2][[irrepidx2]];
  irnameout=IrrepName[pxout, pyout, pzout][[irrepidxout]];


  If[Not[ListQ[CG[{psx1, psy1, psz1}, irname1, {psx2, psy2, psz2} , irname2, {pxout, pyout, pzout} , irnameout, irrepevout]]],Print["Missing the CG coefficients for the given combination, you must generate them"];Abort[];];
  cg=CG[{psx1, psy1, psz1}, irname1, {psx2, psy2, psz2} , irname2, {pxout, pyout, pzout} , irnameout, irrepevout];

  res1 = Sum[aa[Conjugate[cg[[i, 1]]],
    oo[Flatten[{cg[[i, 2]], irrepidx1, charge1, (path1//.findPerm[{px1, py1, pz1},cg[[i, 2, 1]]])//.btoa }]],
    oo[Flatten[{cg[[i, 3]], irrepidx1, charge2, (path2//.findPerm[{px2, py2, pz2},cg[[i, 3, 1]]])//.btoa }]]]
  , {i, 1, Length[cg]}];

  res1 = res1 //. aa[0,_,_] -> 0;

  res1 = Expand[res1 //. { oo[ {a2__}] :> oo[ a2 ] }];
  If[Head[res1] == Plus, 
    res2 = Table[res1[[i]], {i, 1, Length[res1]}];, 
    res2 = {res1} ;
  ];
  cg=res2 //. aa[A_,oo[B__],oo[C__]] :> {A,{B},{C}};

  res=0;
  cg1={};
 (*This is to define the new operator (making sure it exists) and adding all the information as a list that we will call cg*)

  Do[
    lres=0;
    lpx1=cg[[i, 2, 1]];
    lpy1=cg[[i, 2, 2]];
    lpz1=cg[[i, 2, 3]];
    lev1=cg[[i, 2, 4]];
    lridx1=cg[[i, 2, 5]];
    lchg1=cg[[i, 2, 6]];
    lpath1=cg[[i, 2, 7]];

    lpx2=cg[[i, 3, 1]];
    lpy2=cg[[i, 3, 2]];
    lpz2=cg[[i, 3, 3]];
    lev2=cg[[i, 3, 4]];
    lridx2=cg[[i, 3, 5]];
    lchg2=cg[[i, 3, 6]];
    lpath2=cg[[i, 3, 7]];
    
    
    lres+=Add1trOpCorrelators[lpx1, lpy1, lpz1, lridx1, lev1, lchg1, lpath1];
    lres+=Add1trOpCorrelators[lpx2, lpy2, lpz2, lridx2, lev2, lchg2, lpath2];
    
    If[lres==2,
      AppendTo[cg1,cg[[i]]]; 
      res+=lres;
    ];
  ,{i,1,Length[cg]}];
  cg=cg1;
  If[res==0,
    Print["All the requested operators have zero projection onto the given symmetry channel"];
  ,

    Print["Generated 2tr Operator : ",cg,"\n Total P=(",pxout,",", pyout,",", pzout,")\n Irrep=",IrrepName[pxout,pyout,pzout][[irrepidxout]],
        "\n Irrep ev=",irrepevout,"/",Length[bTOrthog[pxout,pyout,pzout][[irrepidxout]]],"\n Charge=",charge]; 
    Print["Operator added to the correlator list.\n\n"];
 
    str = Set2trstring[pxout, pyout, pzout, irrepidxout, irrepevout, charge, path1, px1, py1, pz1, irrepidx1, charge1, path2, px2, py2, pz2, irrepidx2, charge2];
    PrependTo[cg,str];
    Set2trOpidx[str, pxout, pyout, pzout, irrepidxout, irrepevout, charge];
    OpList[pxout, pyout, pzout, irrepidxout, charge, str]=cg;
  ];
];

(* This function generates the position operator in the given irrep. 
The code checks if the path gives rise to a position operator that already exists.
All the indexing is done in OpGenerate
*)

Add1trOpCorrelators[px_, py_, pz_, irrepidx_, irrepev_, charge_, path_]:= Add1trOpCorrelators[px, py, pz, irrepidx, irrepev, charge, path] = Module[{res=0,success=0,eval=True,multbefore},
  If[Not[ListQ[bTOrthog[px, py, pz]]], Print["Missing Coefficient table for the given impulse"]; Abort[];];
  If[Length[bTOrthog[px, py, pz]] < irrepidx || irrepidx < 1 , Print["Number of irreps is not compatible with the requested irrep index"]; Abort[];];
  If[Length[bTOrthog[px, py, pz][[irrepidx]]] < irrepev || irrepev < 1,  Print["Irrep dimension is not compatible with the requested irrep ev"]; Abort[];];
  If[Not[Or[charge==-1, charge==+1]], Print["Charge can only take values +1 or -1"]; Abort[];];

  multbefore=Opindex[px, py, pz, irrepidx, charge, PathUniqueIndex[path]];
  If[NumberQ[multbefore],
    If[Not[SameQ[Opindex[px, py, pz, irrepidx, charge][[multbefore,irrepev]],0]],
      Print["Input path : ",path,"\n Exisiting 1tr Operator : ",OpList[px, py, pz, irrepidx, charge,  Opindex[px, py, pz, irrepidx, charge][[multbefore,irrepev]]],"\n Total P=(",px,",", py,",", pz,")\n Irrep=",IrrepName[px,py,pz][[irrepidx]],
        "\n Irrep ev=",irrepev,"/",Length[bTOrthog[px,py,pz][[irrepidx]]],"\n Charge=",charge];
      Print["Already included.\n\n"];
      eval=False;
    ];
  ];
  (*First generate the operator for the given simmetry channel, only if it doesn't exists in the multiplet already*)
  If[eval,
    res=OpGenerate[px, py, pz, irrepidx, irrepev, charge, path];
  
    If[SameQ[res,0],
      Print["Input path : ",path,"\n Generated 1tr Operator : ",res,"\n Total P=(",px,",", py,",", pz,")\n Irrep=",IrrepName[px,py,pz][[irrepidx]],
        "\n Irrep ev=",irrepev,"/",Length[bTOrthog[px,py,pz][[irrepidx]]],"\n Charge=",charge];
      Print["The operator has zero projection onto the given symmetry channel\n\n"];
      ,
      success=1;

      Print["Input path : ",path,"\n Generated 1tr Operator : ",res,"\n Total P=(",px,",", py,",", pz,")\n Irrep=",IrrepName[px,py,pz][[irrepidx]],
        "\n Irrep ev=",irrepev,"/",Length[bTOrthog[px,py,pz][[irrepidx]]],"\n Charge=",charge]; 
      Print["Operator added to the correlator list.\n\n"];
    ];
  ];

success];

(*This function generates the position space operator {operator, index}, and increments Opindex is the operator is not identically null.
As the function uses the PathUniqueIndex as key the function it is safe when recalled multiple time on the same operator
The function changes twice Opindex adding one element of a multiplet and adding the association with the multiplet id and OpList adding the operator index
It is a sort of old setup and is used only in Add1trOpCorrelators.
*)
OpGenerate[px_, py_, pz_, irrepidx_, irrepev_, charge_, path_] := Module[{res,res1,tres,tmp,nid,opnum},
  If[Not[ListQ[bTOrthog[px, py, pz]]],    Print["Missing Coefficient table for the given impulse"];Abort[];];
  If[Length[bTOrthog[px, py, pz]] < irrepidx || irrepidx < 1 , Print["Number of irreps is not compatible with the requested irrep index"];Abort[];];
  If[Length[bTOrthog[px, py, pz][[irrepidx]]] < irrepev || irrepev < 1,  Print["Irrep dimension is not compatible with the requested irrep ev"];Abort[];];
  If[Not[Or[charge==-1, charge==+1]], Print["Charge can only take values +1 or -1"]; Abort[];];
  If[Not[MatchQ[path,P[__]]],Print["path must be a unique Path quantity P[__]"];Abort[]];
  If[Not[Map[IsIn, path //. P :> List] //. List -> And],Print["Path written in terms of non a-steps"];Abort[]];

  (* Here we create the point operator for the given quantum numbers, this can be done only on unshifted paths*)
  res = Sum[ bTOrthog[px, py, pz][[irrepidx, irrepev, i]] (path //. permutationTable[[i]]), {i, 1, 48}];
  res = res //. btoa;


  (* OpSimplify only shifts the paths in order to identify them uniquelly, the shift is transformed in its numerical value*)
  (* In OpSimplify the paths are added PathUniqueIdentifier and PathIndex*)
  (* The convention here is that a momentum defined operator is evaluated as Sum[Exp[I 2 Pi (n.p)/L] PointOp[n]]*)
  (* This shift represents the difference in position between the shifted and fundamental operators*)
  (* The shift doesn't affect the Conjugate *)
  res = OpSimplify[res];
  
  (*Here we get rid of the shifts that are not useful*)
  If[px==0,res=res //. P[A__][ax_,ay_,az_] :>  P[A][0,ay,az]];
  If[py==0,res=res //. P[A__][ax_,ay_,az_] :>  P[A][ax,0,az]];
  If[pz==0,res=res //. P[A__][ax_,ay_,az_] :>  P[A][ax,ay,0]];

  (* Positive and negative charge can be obtained by a single operator.
   Note that the coefficients btorthog can be complex, here we are exactly using C transformation as path reversal*)
  If[charge==1,
    tres = res //. Conjugate[P[A__][ax_,ay_,az_]] :> Pre[A][ax,ay,az];
    tres = tres //. P[A__][ax_,ay_,az_] :> Pre[A][ax,ay,az];
    res1 = tres;,
    tres = res //. Conjugate[P[A__][ax_,ay_,az_]] :> -Pim[A][ax,ay,az];
    tres = tres //. P[A__][ax_,ay_,az_] :> Pim[A][ax,ay,az];
    res1 = tres;
  ];

  (* So far we have generated and simplified the operator, we must now check that it doesn't already exist.
  Note the that the operator has to be still summed over the lattice for the given momentum, but we have already incorporated all the shifts*)
  
  If[Not[SameQ[res1,0]],
    (*First we check that Opindex is initialized for the given simmetry channel*)
    If[Not[ListQ[Opindex[px, py, pz, irrepidx, charge]]],
      Opindex[px, py, pz, irrepidx, charge]={};
    ];

    (*here we deal with the indexing of one tr operators, they are identified by their original path id*)
    (*We have first to chek if the multiplet associated with the path index already exists, otherwise we create it as a vector of zeros*)
    If[Not[NumberQ[Opindex[px, py, pz, irrepidx, charge, PathUniqueIndex[path]]]],
      tmp = Opindex[px, py, pz, irrepidx, charge];
      AppendTo[tmp,Table[0,{i,1,Length[bTOrthog[px, py, pz][[irrepidx]]]}]];
      Opindex[px, py, pz, irrepidx, charge]=tmp;
      Opindex[px, py, pz, irrepidx, charge, PathUniqueIndex[path]]=Length[tmp];
    ];

    (*nid = id of the operator mutiplet, opnum=id of the operator for the given symmetry channel*)
    nid=Opindex[px, py, pz, irrepidx, charge, PathUniqueIndex[path]];
    opnum=Opindex[px, py, pz, irrepidx, charge][[nid,irrepev]];

    (*if opnum==0 then operator has not yet been inputed for the given simmetry channel and ev, otherwise we are reproposing something that already exists*)
    If[opnum==0,
      opnum=Max[Cases[Flatten[Opindex[px, py, pz, irrepidx,charge]], _Integer]]+1;
      tmp=Opindex[px, py, pz, irrepidx,charge];
      tmp[[nid,irrepev]]=opnum;
      Opindex[px, py, pz, irrepidx,charge]=tmp;
      OpList[px, py, pz, irrepidx, charge, opnum]=res1;
      ,
      Print["Warning, in OpGenerate, you are trying to recreate an operator that already exists"];
    ];

    res={res1, opnum};
  ,
    res=0;
  ];  

  res
];
  
  
  
(*This function takes all the P[..] elements in a and writes them in terms of the fundamental paths with their shifts, 
 it generates also the class of related operators through PathUniqueIdentifier*)

OpSimplify[a_] := Module[{ris = a, Ptemp, tmpris, i, normalization, sqrt},
  ris = Select[Variables[ris], MatchQ[#1, P[__]] &];
  Do[
    tmpris=ris[[i]] //. P[a1__] :> Plus[a1];
    If[Not[SameQ[tmpris,0]],Print["Error [OpSimplify]: Inserted a non closed path"];Abort[]];
    PathUniqueIdentifier[ris[[i]]];
    tmpris = ris[[i]] //. P[a1__] :> Union[{a1}];
    If[Complement[tmpris, {ax, ay, az, -ax, -ay, -az}] != {},
    Print["Error [OpSimplify]: Inserted a path that cannot be ciclic Transformed (quite likelly is written with the wrong unit vectors)"];Abort[];];
  , {i, 1, Length[ris]}];
  ris = a //. P -> Ptemp;
  ris = ris //. Ptemp[b___] :> PathUniqueIdentifier[P[b]][[1]];
  ris = Expand[ris];
ris];

IsInPositive[a1_]:=IntersectingQ[{a1}, {ax, ay, az}];
IsIn[a1_]:=IntersectingQ[{a1}, {ax, ay, az, -ax, -ay, -az}];

(*This function generates also the class of related operators through the selfdefinition of PathUniqueIdentifier of the fundamental paths.
The new paths are identified by an index and the total number of new paths is in pathindex.
It must be a single path as input.

It can be run multiple times*)
PathUniqueIdentifier[a_] := PathUniqueIdentifier[a] = Module[{ris = a,res, Ptemp, tmpris, lper,listris,r3},
  If[Not[NumberQ[pathindex]],pathindex=0];
  If[Not[MatchQ[ris,P[__]]],Print["Requested a PathUniqueIdentifier of a non Path quantity"];Abort[]];
  If[Not[Map[IsIn, ris //. P :> List] //. List -> And],Print["Requested a PathUniqueIdentifier of non a-steps Path "];Abort[]];
  ris = ris //. P -> Ptemp ;
  Ptemp /: Ptemp[-(a1_), a2___] := Ptemp[a2, -a1] /; IsInPositive[a1];
  Ptemp /: Ptemp[a1_, -(a2_), a3___, b1_, b2_, a4___] :=  Ptemp[b1, b2, a4, a1, -a2, a3] /; IsInPositive[a1] && IsInPositive[a2] && IsInPositive[b1] && IsInPositive[b2];
  Ptemp /: Ptemp[a1_, a2_, -(a3_), a4___, b1_, b2_, b3_, a5___] := Ptemp[b1, b2, b3, a5, a1, a2, -a3, a4] /; IsInPositive[a1] && IsInPositive[a2] && IsInPositive[a3] && IsInPositive[b1] && IsInPositive[b2] && IsInPositive[b3];
  Ptemp /: Ptemp[b2_, a2___, b1_] := Ptemp[b1, b2, a2] /; IsInPositive[b1] && IsInPositive[b2];
  Ptemp /: Ptemp[b1_, -(a1_), a2___, -(a3_), ax, -(a4_), a5___] := Ptemp[ax, -a4, a5, b1, -a1, a2, -a3] /;  IsInPositive[a1] && IsInPositive[a3] && IsInPositive[a4] && Intersection[{b1}, {ay, az}] !=  {};
  Ptemp /: Ptemp[az, -(a1_), a2___, -(a3_), ay, -(a4_), a5___] := Ptemp[ay, -a4, a5, az, -a1, a2, -a3] /;  IsInPositive[a1] && IsInPositive[a3] && IsInPositive[a4] && Intersection[{ax}, {a2, a5}] ==  {};
  Ptemp /: Ptemp[b1_, -(a1_), ax, -(a2_), a3___] :=  Ptemp[ax, -a2, a3, b1, -a1] /; IsInPositive[a1] && IsInPositive[a2] && Intersection[{b1}, {ay, az}] != {};
  Ptemp /: Ptemp[az, -(a1_), ay, -(a2_), a3___] := Ptemp[ay, -a2, a3, az, -a1] /; IsInPositive[a1] && IsInPositive[a2] && Intersection[{ax}, {a3}] == {};
  ris = Expand[ris] //. Ptemp -> P;
  tmpris = ris //. P -> List;
  listris = tmpris;
  ris = ris //. P[A1__] :> P1[A1][0,0,0];
  lper = Length[tmpris];
  r3=0;

  Do[
   tmpris = tmpris /. {a1_, a2___, a3_} -> {a3, a1, a2};
    r3 += tmpris[[1]] //. { ax -> {1,0,0} , ay -> {0,1,0} , az -> {0,0,1} };
    res = ris //. P1[A1__][0,0,0] :> P[A1][r3[[1]],r3[[2]],r3[[3]]];
    PathUniqueIdentifier[tmpris //. List -> P] = {res,pathindex};
    PathUniqueIdentifier[Reverse[Expand[-tmpris]] //. List -> P] = {Conjugate[res],pathindex};
  , {i, 1, lper}];

  PathList[pathindex]=ris //. P1[A__][B__] -> P[A];
  pathindex=pathindex+1;
  ris = ris //. P1 -> P;
PathUniqueIdentifier[a]]

(*Short function just to give raise to the unique index of a path*)
PathUniqueIndex[a_]:= PathUniqueIdentifier[a][[2]];

(*Interface function to create the c strings of the numerical values of the coefficientsand functions in GenerateCchecks*)
<< SymbolicC`;
MyCForm[a_] := Module[{res, res1},
   res = ToCCodeString[CExpression[a]];
   res];

(*
This functions not meant to be called by the user.
This function generates the C checks and writes them in the file checkfunctionsfilename .
The idea is to generate the list of operators on a random con O, rotate the configuration with rotation (i) and generate again the operator Oi.
The rotation matrix are contained in irrepsetorthog  we check component by component O=irreppsetothog.O'.
To this end we need to evaluate that all the ev of the given irrep for the given operators have been evaluated (and only then we will generate the checks).
The function need no input, it goes though Opindex to find the operators and uses 
MapOptoCindex for the C indetification of the operators and Oplist for the report in case of error
*)
GenerateCchecks[]:=Module[{Op,OpTmp,ar,irrepdim,EvaluatedQ, RActiveOp,RMatrixOp, Px, Py, Pz, irrepindex, i, charge},
  ar=OpenWrite[checkfunctionsfilename,FormatType->InputForm];
  WriteString[ar,"/*This is an automatically generated function, do not edit.*/\n#define Complex(a,b) ((a)+I*(b))\nstatic int fullcheck(int rotid, double complex *rotated, double complex *unrotated)\n{\n#define rotfun(a) rotated[(a)]\n#define unrotfun(a) unrotated[(a)]\ndouble complex tmp[3];\nint return_value=0;\n"];
  Do[
    Do[
      Do[ 
        If[ListQ[Opindex[Px,Py,Pz,irrepindex,charge]],
          Print["Now checking P="<>ToString[{Px,Py,Pz}]<>"."];
          irrepdim=Length[bTOrthog[Px,Py,Pz][[irrepindex]]];
          Print["Currently checking irrep number "<>ToString[irrepindex]<>", with dim="<>ToString[irrepdim]<>"."];
          Do[
            (*This is to check that all evs for the given irrep have been evaluated*)
            OpTmp=Table[
               Not[SameQ[Opindex[Px,Py,Pz,irrepindex,charge][[id,ev]],0]]
            ,{ev,1,irrepdim}];
            EvaluatedQ=OpTmp//.List -> And;
            If[EvaluatedQ,
              OpTmp=Transpose[{Table[Op[Px,Py,Pz,irrepindex,charge,Opindex[Px,Py,Pz,irrepindex,charge][[id,irev]]],{irev,1,irrepdim}]}];
              RMatrixOp=Table[N[irrepSetOrthog[Px,Py,Pz][[irrepindex]][[i]]] . OpTmp,{i,1,Ord[Px,Py,Pz]}];
              Off[Part::partd];
              OpTmp=ExpandAll[OpTmp//.Op[a__]:>rotfun[MapOptoCindex[a]]];
              Print["The operators: ",OpTmp];
              RMatrixOp=ExpandAll[RMatrixOp//.Op[a__]:>unrotfun[MapOptoCindex[a]]];
              Print["And their rotations: ",RMatrixOp];
              On[Part::partd];
              Do[
                Do[
                  WriteString[ar,"if(",Position[permutationTable,permTab[Px,Py,Pz][[i]]][[1,1]]-1,"==rotid)\n{\n"];
                  WriteString[ar,"tmp[0]=",MyCForm[OpTmp[[j,1]]],";\n"];
                  WriteString[ar,"tmp[1]=",MyCForm[RMatrixOp[[i,j,1]]],";\n"];
                  WriteString[ar,"_complex_mul_star(tmp[2],tmp[0]-tmp[1],tmp[0]-tmp[1]);
if(sqrt(creal(tmp[2]))>=1.e-11){
  lprintf(\"Error\",0,\" Op="];

  If[ListQ  [OpList[Px,Py,Pz,irrepindex,charge,Opindex[Px,Py,Pz,irrepindex,charge][[id,j]]]],
    WriteString[ar,OpList[Px,Py,Pz,irrepindex,charge,Opindex[Px,Py,Pz,irrepindex,charge][[id,j]]][[1]]];
  ,
    WriteString[ar,ToString[OpList[Px,Py,Pz,irrepindex,charge,Opindex[Px,Py,Pz,irrepindex,charge][[id,j]]]]];
  ];
  WriteString[ar,"\\n px=%d py=%d pz=%d Irrep=%d ev=%d charge=%d multiplet id=%d (%2.10e %2.10e) (%2.10e %2.10e) %2.10e \\n\","];
  WriteString[ar,Px,",",Py,",",Pz,",",irrepindex,",",j,",",charge,",",id,",creal(tmp[0]),cimag(tmp[0]),creal(tmp[1]),cimag(tmp[1]),sqrt(creal(tmp[2])));
  return_value++;
  }
}\n"];
                ,{j,1,irrepdim}];
              ,{i,1,Ord[Px,Py,Pz]}];
              ];
            ,{id,1,Length[Opindex[Px,Py,Pz,irrepindex,charge]]}];
          ];
      ,{charge,-1,1,2}];
    ,{irrepindex,1,Length[bTOrthog[Px,Py,Pz]]}];
  ,{Px,-1,1},{Py,-1,1},{Pz,-1,1}];
  WriteString[ar,"#undef unrotfunreturn\n#undef rotfun\n#undef Complex\nreturn return_value;\n}\n"];
  Close[ar];
  ]


(*This function writes the C routines that evaluate the paths' value at a fixed position.
In C it will generate the functions pathn  where is is the unique pathid.
*)

  PathGenerateCcode[idx_] := PathGenerateCcode[idx] = Module[{steps,ar,i},
  If[Not[MatchQ[PathList[idx],P[__]]],Print["In PathGenerateCcode, requested the generation of a path not included in PathList"];Abort[]];
  ar = OpenAppend[opfilename, FormatType -> InputForm];
  (**)
  WriteString[ar, "static double complex path", idx, "(int in)\n"];
  WriteString[ar, "{\nsuNg *w1, *w2;\nsuNg res, res1;\nint site=in;\ndouble complex p;\n\n"];
  steps = PathList[idx] //. P[A__] :> List[A];
  If[posdir[steps[[1]]],
    WriteString[ar, "w2 = pu_gauge_wrk(site,", dir[steps[[1]]], ");\n\n"];,
    WriteString[ar, "site = idn_wrk(site, ", dir[steps[[1]]], ");\n"];
    WriteString[ar, "w2 = pu_gauge_wrk(site,", dir[steps[[1]]], ");\n\n"];
    WriteString[ar, "_suNg_dagger(res1,*w2);\n"];
    WriteString[ar, "w2 = &res1;\n"];
  ];
  (**)
  Do[
    If[posdir[steps[[i - 1]]] && posdir[steps[[i]]],  WriteString[ar, "site = iup_wrk(site, ", dir[steps[[i-1]]], ");\n"];];
    If[Not[posdir[steps[[i - 1]]]] && Not[posdir[steps[[i]]]], WriteString[ar, "site = idn_wrk(site, ", dir[steps[[i]]], ");\n"];];
    If[Not[posdir[steps[[i - 1]]]] && posdir[steps[[i]]], Null];
    If[posdir[steps[[i - 1]]] && Not[posdir[steps[[i]]]],
      WriteString[ar, "site = iup_wrk(site, ", dir[steps[[i - 1]]],");\nsite = idn_wrk(site, ", dir[steps[[i]]], ");\n"];
    ];
  (**)
    WriteString[ar, "w1 = pu_gauge_wrk(site,", dir[steps[[i]]], ");\n"];
    If[posdir[steps[[i]]], WriteString[ar, "_suNg_times_suNg("];,
      WriteString[ar, "_suNg_times_suNg_dagger("];
    ];
  (**)
    If[i == 2, WriteString[ar, " res, *w2, *w1);\n\n"];,
      If[OddQ[i], WriteString[ar, "res1, res, *w1);\n\n"];,
      WriteString[ar, "res, res1, *w1);\n\n"];];
    ];
  ,{i, 2, Length[steps]}];
  (**)
  WriteString[ar, "_suNg_trace(p,res);\nreturn p;\n}\n\n"];
  Close[ar];
  WrittenPaths[idx]=1;
  ]

(*This functions generate the report string: for 1tr operators is just the path, 
for multi tr operator is the long identification string. 
The string will contains "na"  for each element of the multiplets missing, if the multiplet is partially evaluated*)
OpGroupStringPaths[px_, py_, pz_, iridx_, charge_] := 
  Module[{res = Opindex[px, py, pz, iridx, charge], string = "|",tmpstring,i,j,lpath,step},
  Do[
    Do[
      If[NumberQ[ res[[i, j]] ] , 
        If[res[[i, j]] > 0,
          string=string<>ToString[MapOptoCindex[px, py, pz, iridx, charge, res[[i, j]]]]<>"=";
          lpath=OpList[px, py, pz, iridx, charge,res[[i, j]]];
          If[Head[lpath]==Plus,
            lpath=lpath[[1]];
          ];
          lpath = lpath //.  a1_. a_[A__][b__] :> {A} ;
          Do[
            step=lpath[[i]]//.{ax -> x , ay -> y , az-> z};
            string = string <> ToString[step];
          ,{i,1,Length[lpath]}];
        ,
        string = string <> "na";
        ];
      ,
        string=string<>ToString[MapOptoCindex[px, py, pz, iridx, charge, res[[i, j]]]]<>"="<>res[[i, j]];
      ];
      If[j!=Length[res[[i]]], string = string <>","];
    ,{j, 1, Length[res[[i]]]}];
    string = string <> "|";
  ,{i, 1, Length[res]}];
  string]
  
 
 (*
 This is the routine that goes through the lists and prints the code.
 This is a rather wordy routine, in the end it creates the 3 files headers, routines, checks.
 It also fills the MapOptoCindex.
 More deatails are included in the comments bellow.
 *)
  
  GenerateCcode[]:=Module[{idop,opnumberC,localoplist,locmemorymap,testmap,cs,startbase,evalpaths,res,ir1,ir2,path1,path2,llist,lcoeff,locallistop,listelem,lcharge1,lcharge2,llpx1,llpy1,llpz1,llpx2,llpy2,llpz2,llev1,llev2,relsign,ar,opnumber},
  ar=OpenWrite[opfilename, FormatType -> InputForm];
  WriteString[ar, "#include <stdlib.h>\n#include \"global.h\"\n#include \"geometry.h\"\n#include \"suN.h\"\n#include \"utils.h\"\n#include \"glueballs.h\"\n\n"];
   WriteString[ar, "#include <string.h>\n"];
  WriteString[ar,"#define npaths ",pathindex,"\n"];
  WriteString[ar,"static double PI=3.141592653589793238462643383279502884197;\n"];
  WriteString[ar,"static double complex *mom_def_Cp_tr_paths=NULL;\n"];
  WriteString[ar,"static double complex *mom_def_Cm_tr_paths=NULL;\n"];
  WriteString[ar,"static double complex *path_storage=NULL;\n"];

  WriteString[ar, "int ** direct_spatial_rotations(){\nint i;\nint ** res=malloc(sizeof(int *)*48);\nint *res1=malloc(sizeof(int *)*48*4);\nfor (i=0;i<48;i++)\nres[i]=res1+4*i;\n"];
  WriteString[ar,"\n"];
  Do[
  (*write the definition of the rotations and inverse rotations for the C checks in the C file*)
    res={0,ax,ay,az} //. permutationTable[[i]];
    res=res //. {bx->1,by->2,bz->3};
    WriteString[ar, "res1[",(i-1)*4,"]=",res[[1]],";\nres1[",(i-1)*4+1,"]=",res[[2]],";\nres1[",(i-1)*4+2,"]=",res[[3]],";\nres1[",(i-1)*4+3,"]=",res[[4]],";\n"];
  ,{i,1,48}];
  WriteString[ar,"return res;\n}\n"];

  WriteString[ar, "int ** inverse_spatial_rotations(){\nint i;\nint ** res=malloc(sizeof(int *)*48);\nint *res1=malloc(sizeof(int *)*48*4);\nfor (i=0;i<48;i++)\nres[i]=res1+4*i;\n"];
  Do[
    res={0,ax,ay,az} //. inversepermutationTable[[i]];
    res=res //. {bx->1,by->2,bz->3};
    WriteString[ar, "res1[",(i-1)*4,"]=",res[[1]],";\nres1[",(i-1)*4+1,"]=",res[[2]],";\nres1[",(i-1)*4+2,"]=",res[[3]],";\nres1[",(i-1)*4+3,"]=",res[[4]],";\n"];
  ,{i,1,48}];
  WriteString[ar,"return res;\n}\n"];
  Close[ar];


(*This block write the one trace operators as linear combination of the momentum defined sum of paths*)
  Do[
    Do[
      Do[
        If[ListQ[Opindex[px, py, pz, irrepidx,charge]],
          OneTraceOpGenerateCcode[px, py, pz, irrepidx,charge];
        ];
        ,{charge,-1,1,+2}];
    , {irrepidx, 1, Length[bTOrthog[px, py, pz]]}];
  , {px, -1, 1}, {py, -1, 1}, {pz, -1, 1}];

(*
This block allow for the evaluation of the momentum defined paths.
The paths are evaluated only once while each different momentum projection can be re-evaluated independently.
*)
  ar = OpenAppend[opfilename, FormatType -> InputForm];
  WriteString[ar,"static int last_t = -10;\nvoid request_space_paths_evaluation(){last_t=-10;}
  static void eval_time_momentum_glueball_paths(int t, int px, int py, int pz)
  {
    int n_x, n_y, n_z, idx, in;
    double complex ce = 0.;
    if(path_storage==NULL)
      {"];
  WriteString[ar, stringshift];
  WriteString[ar,"        path_storage = malloc(npaths * X * Y * Z * sizeof(double complex));
        mom_def_Cp_tr_paths = malloc(npaths * sizeof(double complex));
        mom_def_Cm_tr_paths = malloc(npaths * sizeof(double complex));
        for (in = 0; in < npaths * X * Y * Z; in++)
            path_storage[in] = 0.;
    }"];
  WriteString[ar,"\nfor(in = 0; in < npaths; in++)\n{\nmom_def_Cp_tr_paths[in]=0.;\n"];
  WriteString[ar,"mom_def_Cm_tr_paths[in]=0.;\n}\n"];
  WriteString[ar,"if (t != last_t)\n{\nlast_t=t;\n"];
  WriteString[ar,"for (n_x = 0; n_x < X; n_x++)\nfor (n_y = 0; n_y < Y; n_y++)\nfor (n_z = 0; n_z < Z; n_z++)\n{\n"];
  WriteString[ar,"in = ipt(t, n_x, n_y, n_z);\nce = cexp(I * 2.0 * PI * (double)(n_x * px + n_y * py + n_z * pz) / GLB_X);\n"];
  WriteString[ar,"idx = npaths * (n_x + X * (n_y + Y * n_z));\n"];
  Do[ 
    If[NumberQ[WrittenPaths[i]],
      WriteString[ar,"path_storage[",i,"+idx]= path",i,"(in);\nmom_def_Cp_tr_paths[",i,"]+=ce*creal(path_storage[",i,"+idx]);"];
      WriteString[ar,"\nmom_def_Cm_tr_paths[",i,"]+=I*ce*cimag(path_storage[",i,"+idx]);\n"];
    ];
  ,{i,0,pathindex-1}];
  WriteString[ar,"}\n}\nelse{\n"];
  WriteString[ar,"for (n_x = 0; n_x < X; n_x++)\nfor (n_y = 0; n_y < Y; n_y++)\nfor (n_z = 0; n_z < Z; n_z++)\n{\n"];
  WriteString[ar,"ce = cexp(I * 2.0 * PI * (double)(n_x * px + n_y * py + n_z * pz) / GLB_X);\n"];
  WriteString[ar,"idx = npaths * (n_x + X * (n_y + Y * n_z));\n"];
  
  WriteString[ar,"for (int i = 0; i < ",pathindex,"; i++)\n{\nmom_def_Cp_tr_paths[i]+=ce*creal(path_storage[i+idx]);\n"];
  WriteString[ar,"mom_def_Cm_tr_paths[i]+=I*ce*cimag(path_storage[i+idx]);\n}\n"];

  
  WriteString[ar,"}\n}\n};\n"];
  (**)
  (*In this block we combine the evaluation of momentum projected trace with the evaluation of the 1tr operators first 
  and then we recombine them to create the multi trace operators*)
  WriteString[ar, "void eval_all_glueball_ops(int t, double complex *numerical_op_out)
{
    static double complex *numerical_op = NULL;
    if (numerical_op == NULL)
    {
        numerical_op = malloc(total_n_glue_op * sizeof(double complex));
    }
    request_space_paths_evaluation();\n"];
  opnumberC=0;
  Do[
    evalpaths=0;
    Do[
      Do[
        (*evaluation of momentum projection is needed only for 1tr operators*)
        If[ListQ[Opindex[px, py, pz, irrepidx,charge]],
          If[evalpaths==0 &&  Select[Flatten[Opindex[px, py, pz, irrepidx,charge]], IntegerQ[#] && # > 0 &] !={}, 
            WriteString[ar,"    eval_time_momentum_glueball_paths(t,",px,",",py,",",pz,");\n"];
            evalpaths=1;
          ];

          Do[
            Do[
              idop = Opindex[px, py, pz, irrepidx,charge][[nop, irrepev]];
              (*We are enforcing that different operators (both 1tr and multiple traces) with same px, py, pz, irrepidx, irrepev, charge are contigous in numerical_op*)
                If[Not[SameQ[idop,0]],
                  If[NumberQ[idop],
                  (*one trace operator*)
                    WriteString[ar, "    OP_oneTr_p_", p[px], "_", p[py], "_", p[pz],"_Ir_", irrepidx, "_C_",p[charge],"_n_", idop,"(numerical_op+",opnumberC,");\n"];
                    MapOptoCindex[px,py,pz,irrepidx,charge,idop]=opnumberC;
                    opnumberC++;
                  ,
                  (*Multiple trace operator*)
                    MapOptoCindex[px,py,pz,irrepidx,charge,idop]=opnumberC;
                    opnumberC++;
                  ];
                ];
             , {nop, 1, Length[Opindex[px, py, pz, irrepidx,charge]]}];
          , {irrepev, 1, Length[bTOrthog[px, py, pz][[irrepidx]]]}];
        ];
      ,{charge,-1,1,2}];
    , {irrepidx, 1, Length[bTOrthog[px, py, pz]]}];
  , {px, -1, 1}, {py, -1, 1}, {pz, -1, 1}];
(**)

(*This is the block for the multi trace operators*)
(* at the moment allows only for 2 tr operators and needs to be exteneded in case of multi operators*)
opnumber=0;
Do[
    Do[
      Do[
        If[ListQ[Opindex[px, py, pz, irrepidx,charge]] ,
          Do[
            locallistop=Select[Flatten[Opindex[px, py, pz, irrepidx,charge][[All,irrepev]]],StringQ[#]&];            
            Do[
              listelem=OpList[px, py, pz, irrepidx,charge, opstr];
              opnumber=MapOptoCindex[px,py,pz,irrepidx,charge,listelem[[1]]];
              WriteString[ar, "    *(numerical_op+",opnumber,")="];
              Do[
                lcoeff=listelem[[cgid,1]];
               
                llpx1=listelem[[cgid, 2, 1]];
                llpy1=listelem[[cgid, 2, 2]];
                llpz1=listelem[[cgid, 2, 3]];
                ir1=listelem[[cgid, 2, 4]];
                llev1=listelem[[cgid, 2, 5]];
                lcharge1=listelem[[cgid, 2, 6]];
                path1=listelem[[cgid, 2, 7]];
               
                llpx2=listelem[[cgid, 3, 1]];
                llpy2=listelem[[cgid, 3, 2]];
                llpz2=listelem[[cgid, 3, 3]];
                ir2=listelem[[cgid, 3, 4]];
                llev2=listelem[[cgid, 3, 5]];
                lcharge2=listelem[[cgid, 3, 6]];
                path2=listelem[[cgid, 3, 7]];

                GenerateCoefficientString[lcoeff];

                s1="(*(numerical_op+"<>ToString[MapOptoCindex[llpx1, llpy1, llpz1, ir1, lcharge1, Opindex[llpx1, llpy1, llpz1, ir1, lcharge1, PathUniqueIndex[path1]]]]<>"))";
                s2="(*(numerical_op+"<>ToString[MapOptoCindex[llpx2, llpy2, llpz2, ir2, lcharge2, Opindex[llpx2, llpy2, llpz2, ir2, lcharge2, PathUniqueIndex[path2]]]]<>"))";

                If[ StringQ[s1] && StringQ[s2],
                  WriteString[ar, OpConsts[lcoeff],"*(",s1,")*(",s2,")"];
                  ,
                  Print["Error in writing the C code, the 2tr operator cannot be anaylitically zero at this stage"];
                  Abort[];
                ];
              ,{cgid,2,Length[listelem]}];
              WriteString[ar,";\n"];
            ,{opstr,locallistop}];
          , {irrepev, 1, Length[bTOrthog[px, py, pz][[irrepidx]]]}];
        ];
      ,{charge,-1,1,2}];
    , {irrepidx, 1, Length[bTOrthog[px, py, pz]]}];
  , {px, -1, 1}, {py, -1, 1}, {pz, -1, 1}];

WriteString[ar,"    for(int i=0;i<total_n_glue_op;i++)
        *(numerical_op_out+i)+=*(numerical_op+i);
}\n"];

(*This is the evaluation and collection on the root node of the 1pt functions*)
  WriteString[ar, "
void evaluate_1pt_functions(cor_list *lcor, int nblocking, double complex *gb_storage)
{
    int n1, n2, i;
    static double complex *gb1_bf;
    static int n_total_active_slices = 0;    
    static int *listactive = NULL;
    if (listactive == NULL)
    {
        listactive = malloc(sizeof(int) * GLB_T);
        for (i = 0; i < GLB_T; i++)
            listactive[i] = -1;

        for (i = 0; i < lcor->n_entries; i++)
        {
            listactive[lcor->list[i].t1] = 1;
            listactive[lcor->list[i].t2] = 1;
        }

        for (i = 0; i < GLB_T; i++)
            if (listactive[i] == 1)
            {
                listactive[i] = n_total_active_slices;
                n_total_active_slices++;
            }
    }


#ifdef WITH_MPI
    static int *t_to_proc = NULL;
    static int *listsent = NULL;
    int t1,t2;

    if (t_to_proc == NULL)
    {
        listsent = malloc(sizeof(int) * GLB_T);

        gb1_bf = malloc(sizeof(double complex) * total_n_glue_op * nblocking * n_total_active_slices);

        t_to_proc = malloc(sizeof(int) * GLB_T);
        for (i = 0; i < GLB_T; i++)
        {
            int x[4] = {i, 0, 0, 0}, p[4];
            glb_to_proc(x, p);
            t_to_proc[i] = p[0];
        }
    }

    for (i = 0; i < GLB_T; i++)
        listsent[i] = -1;

    static double complex *gb2;
    static double complex *gb1;
    MPI_Request req_1pt[GLB_T];

    for (int icor = 0; icor < lcor->n_entries; icor++)
    {

        t1 = glbT_to_active_slices[lcor->list[icor].t1];
        t2 = glbT_to_active_slices[lcor->list[icor].t2];
        gb1 = gb1_bf + total_n_glue_op * nblocking * listactive[lcor->list[icor].t1];
        gb2 = gb1_bf + total_n_glue_op * nblocking * listactive[lcor->list[icor].t2];

        if (listsent[lcor->list[icor].t1] == -1)
        {
            if (t1 != -1)
            {
                listsent[lcor->list[icor].t1] = 0;
                if (PID == 0)
                {
                    memcpy(gb1, gb_storage + t1 * total_n_glue_op * nblocking, sizeof(double complex) * total_n_glue_op * nblocking);
                }
                else
                {
                    MPI_Isend((double *)(gb_storage + t1 * total_n_glue_op * nblocking), total_n_glue_op * nblocking * 2, MPI_DOUBLE, 0, lcor->list[icor].t1, cart_comm, req_1pt + lcor->list[icor].t1);
                }
            }

            if (PID == 0 && t1 == -1)
            {
                MPI_Irecv((double *)(gb1), total_n_glue_op * nblocking * 2, MPI_DOUBLE, t_to_proc[lcor->list[icor].t1], lcor->list[icor].t1, cart_comm, req_1pt + lcor->list[icor].t1);
                listsent[lcor->list[icor].t1] = 1;
            }
        }

        if (listsent[lcor->list[icor].t2] == -1)
        {
            listsent[lcor->list[icor].t2] = 0;
            if (t2 != -1)
            {
                if (PID == 0)
                {
                    memcpy(gb2, gb_storage + t2 * total_n_glue_op * nblocking, sizeof(double complex) * total_n_glue_op * nblocking);
                }
                else
                {
                    MPI_Isend((double *)(gb_storage + t2 * total_n_glue_op * nblocking), total_n_glue_op * nblocking * 2, MPI_DOUBLE, 0, lcor->list[icor].t2, cart_comm, req_1pt + lcor->list[icor].t2);
                }
            }

            if (PID == 0 && t2 == -1)
            {
                MPI_Irecv((double *)(gb2), total_n_glue_op * nblocking * 2, MPI_DOUBLE, t_to_proc[lcor->list[icor].t2], lcor->list[icor].t2, cart_comm, req_1pt + lcor->list[icor].t2);
                listsent[lcor->list[icor].t2] = 1;
            }
        }
    }
    if (PID == 0)
        for (i = 0; i < GLB_T; i++)
            if (listsent[i] == 1)
            {
                MPI_Wait(req_1pt + i, MPI_STATUS_IGNORE);
            }

#else
    gb1_bf = gb_storage;
#endif

"];

startbase=0;

Do[
    Do[
      Do[
        Do[        
          cs=0;
          If[ListQ[Opindex[px, py, pz, irrepidx, charge]],
            (*this is the list of the operators, they are meant to be contigous in memory*)
            localoplist=Complement[Opindex[px, py, pz, irrepidx, charge][[All,irrepev]],{0}];
            (*checking that the operators are contigous in memory*)
            If[localoplist!={},
              locmemorymap=MapOptoCindex[px, py, pz, irrepidx, charge, #] & /@ Complement[Opindex[px, py, pz, irrepidx, charge][[All, irrepev]], {0}];
              locmemorymap=Sort[locmemorymap];
              testmap=Table[i,{i,Min[locmemorymap],Max[locmemorymap]}];
              If[Not[SameQ[testmap,locmemorymap]],Print["There is an error in the MapOptoCindex ordering.",locmemorymap];Abort[];];
              cs=Max[locmemorymap]-Min[locmemorymap]+1;
            ];
          ];
 
 
          If[cs>0,
            WriteString[ar, "
    lprintf(\"Measure ML\", 0, \"\\n1pt function P=(",px,",", py,",", pz,") Irrep=",IrrepName[px,py,pz][[irrepidx]]," Irrep ev=",irrepev,"/",Length[bTOrthog[px,py,pz][[irrepidx]]]," Charge=",stcharge[charge]," nop=%d\\n\",",cs," * nblocking );
    lprintf(\"Measure ML\", 0, \"Op id=",MyRangeString[startbase,startbase-1+cs]," (repeated nblocking times)\\n\");
    for (n1 = 0; n1 < GLB_T; n1++)
        if (listactive[n1] > -1)
        {
            lprintf(\"Measure ML\", 0, \" t=%d\", n1);
            for (n2 = 0; n2 < nblocking; n2++)
                for (i = ",startbase,"; i < ",startbase+cs,"; i++)
                    lprintf(\"Measure ML\", 0, \" ( %.10e %.10e )\", creal(gb1_bf[i + total_n_glue_op * (n2 + nblocking * listactive[n1])]),
                            cimag(gb1_bf[i + total_n_glue_op * (n2 + nblocking * listactive[n1])]));
            lprintf(\"Measure ML\", 0, \"\\n\");
        }
"];
           startbase+=cs;
          ];
        ,{irrepev, 1, Length[bTOrthog[px, py, pz][[irrepidx]]]}];
      , {charge, -1, 1, 2}];
    , {irrepidx, 1, Length[bTOrthog[px, py, pz]]}];
  , {px, -1, 1}, {py, -1, 1}, {pz, -1, 1}];
  WriteString[ar, "}\n"];
(*Report function on the operator evaluated*)
  WriteString[ar, "void report_op_group_setup()\n{\n"];
  Do[
    Do[
      Do[
          If[ListQ[Opindex[px, py, pz, irrepidx, charge]],
            If[Complement[Flatten[Opindex[px, py, pz, irrepidx, charge]],{0}]!={},
              WriteString[ar, "lprintf(\"INIT Measure ML\",0,\"\\n1pt Irrep multiplets Total P=(", px, ",", py, ",", pz, ") Irrep=", IrrepName[px,py,pz][[irrepidx]]," Charge=", stcharge[charge], "\");\n"];
              WriteString[ar, "lprintf(\"INIT Measure ML\",0,\" " <> OpGroupStringPaths[px, py, pz, irrepidx, charge] <>"\");\n"];
            ];
          ];
      , {charge, -1, 1, 2}];
    , {irrepidx, 1, Length[bTOrthog[px, py, pz]]}];
  , {px, -1, 1}, {py, -1, 1}, {pz, -1, 1}];
  WriteString[ar, "}\n"];
  Close[ar];

  GenerateCheader[opnumberC];
  
  GenerateCchecks[];
  
  ]


(*This is the function that actually writes the operator for C measurments assuming that trace momentum defined operators have been evaluated*)
  OneTraceOpGenerateCcode[px_, py_, pz_, irrepidx_,charge_] := OneTraceOpGenerateCcode[px, py, pz, irrepidx,charge] = Module[{coeff,paths,shifts,op,oplist,listopidx},
  listopidx=Select[Flatten[Opindex[px, py, pz, irrepidx,charge]],IntegerQ[#] && # > 0 &];
  Do[
    op=OpList[px, py, pz, irrepidx, charge, opidx];
    If[FreeQ[op, Pre] && FreeQ[op, Pim]  , Print["The request operator index has not yet been evaluated"];Abort[]];
    If[SameQ[Head[op],Plus],oplist=op//. Plus->List;,oplist={op}];
    coeff=oplist//.{Pre[__][__]-> 1, Pim[__][__]-> 1};
    paths=oplist//.{A_. Pre[b__][nx_,ny_,nz_] :> {P[b],Exp[-I 2 Pi /L (px nx+py ny +pz nz)],0}, A_. Pim[b__][nx_,ny_,nz_] :> {P[b],Exp[-I 2 Pi /L (px nx+py ny +pz nz)],1}};
    If[Not[AllTrue[paths[[All,1]], Not[FreeQ[#, P[__]]] &]],Print["1 The request operator has a non P based structure:",op];Abort[]];
    If[Not[AllTrue[coeff, NumberQ[N[#]] &]],Print["2 The request operator has a non P based structure:",op];Abort[]];
    If[Length[coeff]!=Length[paths],Print["3 The request operator has a non P based structure:",op];Abort[]];
  (**)
  (**)

    (*Each path code is generated only once and only if it has been requested, it imples that also some paths can be not evaluated*)

    Do[
      PathGenerateCcode[PathUniqueIndex[paths[[i,1]]]];
    ,{i,1,Length[paths]}];
  (**)
  (**)
    Do[
      GenerateCoefficientString[coeff[[i]]];
     ,{i,1,Length[coeff]}];
   (**)

    shifts=Complement[Union[paths[[All,2]]],{1}];
    Do[WriteShift[shifts[[i]]],{i,1,Length[shifts]}];

    ar = OpenAppend[opfilename, FormatType -> InputForm];
    WriteString[ar, "static void OP_oneTr_p_",p[px],"_",p[py],"_",p[pz],"_Ir_",irrepidx,"_C_",p[charge],"_n_",opidx,"(double complex * op_out)\n"];
    WriteString[ar,"{\n*op_out ="];
    Do[
      WriteString[ar,OpConsts[coeff[[i]]]];
      If[Abs[coeff[[i]]]!=1,WriteString[ar,"*"]];
      If[Not[SameQ[paths[[i,2]],1]],WriteString[ar,MapShifts[paths[[i,2]]],"*"]];
      If[paths[[i,3]]==0,WriteString[ar,"mom_def_Cp_tr_paths["],WriteString[ar,"mom_def_Cm_tr_paths["]];
      WriteString[ar,PathUniqueIndex[paths[[i,1]]],"]"];
    ,{i,1,Length[paths]}];
    WriteString[ar,";
    }\n\n"];
    Close[ar];
  ,{opidx,listopidx}];

  ]
  
  
  stringshift="";
  stringshiftidx=0;

  (*Map of the global shifts*)
  WriteShift[shift_]:=Module[{cc=ExpandAll[shift],ar},
    If[Not[StringQ[MapShifts[cc]]],
      MapShifts[cc]="c"<>ToString[stringshiftidx];
      ar = OpenAppend[opfilename, FormatType -> InputForm];
      WriteString[ar,"static double complex c",stringshiftidx,";\n"];
      stringshift=stringshift<>"c"<>ToString[stringshiftidx]<>"=cexp(I*PI*("<>MyCForm[N[PowerExpand[Log[cc]] L/(I Pi),18]]<>"/GLB_X));\n";
      stringshiftidx++;
      Close[ar];
    ];
  ];

  sign[a_]:=Module[{res},If[a>0,res="+",res="-"];res];
  

    (*Function to write the coefficients in C*)
  GenerateCoefficientString[coef_]:=GenerateCoefficientString[coef]=Module[{cc=ExpandAll[coef],string=""},    
    If[Not[StringQ[OpConsts[cc]]],
      If[Abs[cc]!=1,
        If[Re[cc]!=0,string=ToString[CForm[N[Re[cc], 18]]]];
        If[Im[cc]!=0,string=string<>sign[Im[cc]]<>"I*"<>ToString[CForm[N[Abs[Im[cc]], 18]]]];
        OpConsts[cc]="+("<>string<>")";,
        OpConsts[cc]=sign[cc];
      ];
    ];
  ];
(*Write the headers*)
  GenerateCheader[maxopCnumber_] := Module[{res,ar},
    ar = OpenWrite[headerfilename, FormatType -> InputForm];
    WriteString[ar, "#ifndef GLUEBALLS_H
#define GLUEBALLS_H
#include \"hr_complex.h\"
#include \"logger.h\"

int **direct_spatial_rotations();
int **inverse_spatial_rotations();
void request_spatial_paths_evaluation();
void eval_all_glueball_ops(int t, double complex *numerical_op);
void measure_1pt_glueballs(int nblocking, double *smear_val, double complex *gb_storage);
void report_op_group_setup();

typedef struct
{
    int t1;
    int t2;
    int id;
    int n_pairs;
} cor_points;

typedef struct
{
    int n_entries;
    cor_points *list;
    int n_corrs;
} cor_list;

void evaluate_1pt_functions(cor_list *lcor, int nblocking, double complex *gb_storage);
    "];
    WriteString[ar, "\n\n"];
(*
    Do[
      Do[
        WriteString[ar, "#define dim_p_", p[px], "_", p[py],"_", p[pz], "_Ir_", irrepidx," ",Length[bTOrthog[px, py, pz][[irrepidx]]],"\n"];
        Do[
        WriteString[ar, "#define n_OP_oneTr_p_", p[px], "_", p[py],"_", p[pz], "_Ir_", irrepidx,"_C_",p[charge]," "];
        If[ListQ[Opindex[px, py, pz, irrepidx,charge]],
          WriteString[ar, Max[Cases[Flatten[Opindex[px, py, pz, irrepidx,charge]], _Integer]],"\n"];
          WriteString[ar, "void OP_oneTr_p_", p[px], "_", p[py],"_", p[pz], "_Ir_", irrepidx, "_C_",p[charge],"(double complex * numop);\n"];
          ,WriteString[ar, "0\n"];
        ];
      ,{charge,-1,1,2}];
      , {irrepidx, 1, Length[bTOrthog[px, py, pz]]}];
    , {px, -1, 1}, {py, -1, 1}, {pz, -1, 1}];
    *)
    WriteString[ar, "#define total_n_glue_op ",maxopCnumber,"\n"];
    WriteString[ar,"#endif\n"];
    Close[ar];
    ];


    EndPackage[];
